# 循环结构

## 1.三种循环语句

C语言中共有三种循环语句，分别是`while`循环，`for`循环和`do-while`循环。

### 1.1 while循环

`while`循环属于最基础的一种循环。

#### 1.1.1 语法格式

```C++
while (条件表达式) 
      循环体 ；              
```

#### 1.1.2执行流程

![img](https://gcn59lcrd80x.feishu.cn/space/api/box/stream/download/asynccode/?code=NDQ3MTg1ZmM3ZGEyNzRjZjJlYzE3MDUwMTZhYzA4ZDBfQTc2anBlMU9kQUF1eHJ1R3ZMQmVOMmNSMllmZnd4ZkFfVG9rZW46SUtuaWJCSHR6b0lKNm14clhGcGM2VkxRbkhjXzE3NzEwNjEyODE6MTc3MTA2NDg4MV9WNA)

如果表达式为真 (true)，则执行循环体语句，然后重新判断表达式的真假，然后重新判断条件；   

如果表达式为非真 (false)，则跳过循环体语句，执行`while`语句后的其他语句，结束该流程。

#### 1.1.3while和if的对比

在学习的过程中，我们会发现，`if`和`while`的语法格式非常相似。那么两者有何区别呢？

我们列举一个具体的场景：我们要依次打印出0~2三个数字。

首先来看if：

```C++
#include <stdio.h>
int main() {
    int i = 0;                     // 初始化计数器
    if (i < 3) {                   // 检查一次条件
        printf("%d\\n", i);         // 条件为真，执行一次
        i++;                       // i 增加 1
    }                              // 条件不再检查，直接结束
    return 0;
}
```

运行结果：

```C++
0
```

结果为什么只打印了一次呢？是 因为 `if` 语句只判断了一次 i < 3，执行完一次后，程序流直接跳过了 `if` 块，后面没有循环回去再检查条件。

而`while`就不一样了：

```C++
#include <stdio.h>
int main() {
    int i = 0;                     // 初始化计数器
    while (i < 3) {                // 检查条件，满足则进入循环
        printf("%d\\n", i);         // 打印当前值
        i++;                       // i 增加 1
    }                              // 循环结束后再次检查条件
    return 0;
}
```

运行结果：

```C++
0
1
2
```

这次我们成功打印出了0、1、2三个数字，是因为while 循环的工作方式是：检查条件 → 执行循环体 → 再次检查条件。只要 i 小于 3，循环体就会重复执行。每次循环结束后，i 增加 1，直到 i 变成 3（不满足 i < 3），循环才终止。

例1：计算1~10的和

```C++
#include <stdio.h>
int main()
{
    int sum = 0;
    int i=1;
    
    while(i <= 10) {
        sum += i;
        i++;
    }
    
    printf("1 到 10 的和是: %d\\\\n", sum);
    return 0;
}    
    
```

运行结果：

```C++
1~10之和为55
```

#### 1.4循环的三要素

循环的三要素分别为：初始化，条件判断和更新迭代。

- 初始化（Initialize）：

初始化的位置通常是在 while 循环之前，它的作用是为循环计数器（i）和其他变量（sum）赋予初始值。如果没有初始化，变量可能会是随机值，导致循环行为不可预测。

设置的初始条件只执行一次，可以有零个人，一个或多个变量设置初值。

- 条件判断（Condition）：

条件判断的位置则是在`while` 后面的括号内。确保每次循环开始时都会执行这个条件，半段是否继续循环。只要条件为真（true），循环体就会执行。如果条件一开始就是假，循环体可能一次都不执行。

- 更新迭代（Update）：

最后迭代的位置通常写在 `while` 循环体的最后一行（在 {} 里）。作用：更新循环计数器（这里是 i++），以及处理循环中产生的中间结果（这里是 sum += i）。这是防止循环无限进行（死循环）的关键。如果没有这一步，i 的值永远不会变化，条件 i <= 10 永远为真，程序会卡死。

```C++
初始化；
while （条件判断）{
       语句；
       更新迭代；
}
```

我们通过上面1~10求和的例子，来加深一下对循环三要素的理解：

```C++
#include <stdio.h>
int main() {
    // 1. 初始化：定义变量并赋初值
    int i = 1;          // 计数器，从 1 开始
    int sum = 0;        // 累加和，初始为 0

    // 2. while 循环（条件判断）
    while (i <= 10) {   // 条件：当 i 小于等于 10 时继续循环
        sum += i;       // 3. 迭代（更新）：累加当前的 i 到 sum
        i++;            // 3. 迭代（更新）：计数器 i 加 1，准备判断下一个数
    }

    // 循环结束后，输出结果
    printf("1 到 10 的和是: %d\\\\n", sum);
    return 0;
}
```

### 1.2 for循环

在`while`循环的基础上升级，就来到了`for`循环。

#### 1.2.1语法格式

```C++
for (初始化;条件判断;更新迭代) {
    语句；                    // 循环体：每次循环执行的代码
}
```

在此处，我们稍加观察后会发现，`for`循环和`while`循环在实现循环的过程中都有初始化，条件判断和更新迭代这三部分，且两种形式无条件等价；但是，`for`循环的三要素更加集中，方便修改，`while`循环的三要素，则散落在各处，不方便集中管理，所以在选择循环语句时，`for`循环的使用更加频繁。

但`for`循环的格式并不唯一，现将：初始化，条件判断，更新迭代三部分，分别对应为表达式1，表达式2，表达式3。我们分别可以省略表达式1，表达式2，表达式3，要注意的是表达式之间的`；`不能省略，但是这样的循环是不完整的，我们需要参考`while`循环的格式在对应的地方补充缺失的语句：

- 

```C++
for(;表达式2；表达式3)
   语句；
表达式1；
for(;表达式2；表达式3)
   语句；
```

- 

```C++
for(表达式1；；表达式3)
   语句；
```

这种情况下，条件默认为真，就会陷入到无限循环中，需要谨慎使用。

```C++
for(表达式1；；表达式3){
   if（表达式2）
   break；
   语句；
}
```

- 

```C++
for(表达式1；表达式2；)
   语句；
for(表达式1；表达式2；) {
   语句；
   表达式3；
}   
```

- 

```C++
for(；表达式2；)
   语句；
表达式1；
for(；表达式2；) {
   语句；
   表达式3；
}   
```

- 

```C++
for(；；)
   语句；
```

此时会无休止的循环`语句`，显然并没有有实用价值。

#### 1.2.2 执行流程

![img](https://gcn59lcrd80x.feishu.cn/space/api/box/stream/download/asynccode/?code=MGExZWMxMGE1YWI3MTc2ZDkxYzAzOTA4MGQ0OWM1MWJfbEcyVFFBQzZoRHZnSkZ2WUVPOTIwTWZsRFhaS3RKbVlfVG9rZW46RVNybGJTcVhzb0p2Z2d4WmtXMmNyajl5blFlXzE3NzEwNjEyODE6MTc3MTA2NDg4MV9WNA)

如果“条件判断”的表达式为真 (true)，则执行for循环体与后续循环语句，然后重新判断条件； 如果“条件判断”的表达式为非真 (false)，则跳过循环体，直接执行下一条语句。

例2：计算10!(10! = 1*2*3*......*10)

```C++
#include <stdio.h>
int main ()
{
    int factorial = 1;                //定义阶乘的最终值
    int i;                            //若不赋值则默认factorial = 0

    for(i = 1; i <= 10; i++) {
        factorial = factorial * i;    //for循环可以直接在循环体内初始化
    }
    
    printf("10!的值为%d",factorial);
    
    return 0;
}
```

在上面的`for循环`体内

- `i = 1`是初始化
- `i <= 10`是条件判断
- `i++`是更新迭代

### 1.3 do-while循环

相较于前两种循环，`do-while`循环在实际开发中的使用频率较低，`do-while`循环同`while`循环和`for`循环的最大区别在于先执行后判断。即使循环条件一开始就不满足，循环体也会执行一次。

#### 1.3.1语法格式

```C++
do {
    // 循环体代码：这里的代码会**至少执行一次**
    } 
while (条件表达式);  // 注意：这里的条件表达式后面必须加分号
```

#### 1.3.2 执行流程

![img](https://gcn59lcrd80x.feishu.cn/space/api/box/stream/download/asynccode/?code=ODA0ZTNlNDRiZTFlZjAwMTBkNTg1YjJiM2QxNzE1MWFfc3VINVVpNmI2eEk1YjFlaGU5dmtpaUxSU2l5V205bFdfVG9rZW46VVFRamJsWkhUb3NJQnF4YUVFWWNzTnpGbkJkXzE3NzEwNjEyODE6MTc3MTA2NDg4MV9WNA)

先执行`do-while`循环体与后续循环语句，再判断条件： 如果“条件判断”的表达式为真 (true)，则重新执行`do-while`循环体； 如果“条件判断”的表达式为非真 (false)，则跳过循环，执行下一条语句。

例3：

```C++
    int i = 1;
    int sum = 0;
    
    do {                  
        sum = i + sum; 
        //无论初始条件中 i 是否满足 i>10，循环体都至少会执行一次             
        }
        //do-while 的写法格式需特别注意
    while(i > 10);
    
    printf("%d", sum);
        
    return 0;
```

输出结果:

```C++
1
```

### 1.4 死循环

在上述的讲解中，我们会发现循环中会出现无限循环的问题，我们也称其为死循环。

死循环（Infinite Loop）指的是一种循环结构，其循环条件始终满足（通常为 true），导致循环体中的代码会被反复执行，除非通过特殊手段（如 `break` 语句、`return` 语句或外部中断）跳出循环，否则程序将永远停留在这个循环中。

在 C 语言中，最典型的死循环有以下两种：

```C++
// 方式一：while 循环
while (1) {
    // 这里的代码会被无限执行
}

// 方式二：for 循环
for (;;) {
    // 这里的代码也会被无限执行
}
```

导致死循环的常见原因：

- 条件永远为真：循环条件设置不当，如`while`(i >= 0)（i从0递增永远大于等于0）。
- 循环变量未变化：循环内部忘记修改条件变量（如忘记i++），导致条件永远满足。
- 更新方向错误：循环变量递增或递减的方向与条件判断不匹配（如`while`(i<10){i--;}）。
- 逻辑错误：循环体内部的操作导致条件始终满足（如使用`continue`跳过了关键的递增语句）。

我们可以通过以下三种方式跳出死循环，其具体的运用我们会在其他章节中详细展开：

- `break`语句：立即终止循环。
- `return`语句：退出当前函数（若在`main`中则结束程序）。
- `goto`语句：跳转到循环外的标签（不推荐）。

由此我们可以看出，循环内部必须有明确的代码（如i++）来改变条件变量，也就是循环三要素中的更新迭代；同时也可以设置一个防御性阈值，即使逻辑有误也能跳出循环（如if(i>1000) break;）

## 2.break和continue语句

在上一节中我们提到循环执行过程中，会遇到一些特殊情况，需要提前终止循环，C语言中为我们提供了`break`和`continue`两种语句来提前结束循环。

### 2.1break语句

```C++
break;   //分号结束，不加括号
```

当程序执行到 `break` 语句时，循环立即终止，不再执行循环体中 `break` 后面的代码，也不再检查循环条件。在 `while`(true) 或 for(;;) 这种无限循环中，`break` 是唯一的退出方式。

例：密码验证器

```C
#include <stdio.h>

int main()
{
    int password;
    int correct_password = 1234;

    // 使用 while(1) 开启无限循环，因为我们不知道用户第几次能输对
    while (1) {
        printf("请输入四位密码: ");
        scanf("%d", &password);

        if (password == correct_password) {
            printf("密码正确，欢迎回来！\n");
            
            break;    // 关键点：一旦执行 break，程序会直接跳到第 25 行执行
        }
        
        printf("密码错误，请重新输入。\n");
        // 如果没触发 break，程序会回到第 10 行继续循环
    }

    printf("程序已退出循环，进入主菜单...\n");

    return 0;
}
```

![img](https://gcn59lcrd80x.feishu.cn/space/api/box/stream/download/asynccode/?code=MTBiY2IyZmQ5NmI4ZDU4ZTI4ZGU3ZWM4ODhkMmUwY2RfOHRXNjNSU0o0eE1iejlrS3VqQ2liNGRzZ1NBblVVdkRfVG9rZW46UzJKNGJ6STFUb2ZhRVN4WEtpT2M4N3FXbmZpXzE3NzEwNjEyODE6MTc3MTA2NDg4MV9WNA)

### 2.continue语句

```C++
continue;    //分号结束，不加括号
```

当执行到 `continue` 时，循环体中 `continue` 之后的代码将被忽略，不会执行。

例：我们要打印 1 到 20 之间的数字，但如果这个数字是 **7 的倍数**，我们就不打印它，而是用“跳过”字样代替。

```C
#include <stdio.h>

int main()
{
    int i;

    for (i = 1; i <= 20; i++) {
        // 判断 i 是否为 7 的倍数
        if (i % 7 == 0) {
            printf("跳过 ");
            
            continue;    // 关键点：执行后直接冲向 i++，不再执行下面的 printf
        }

        printf("%d ", i);
    }

    printf("\n程序运行结束。\n");

    return 0;
}
```

![img](https://gcn59lcrd80x.feishu.cn/space/api/box/stream/download/asynccode/?code=NzJlNWVkY2ZmNjk4MDc4MzBhOWU3MTE0MTZkMWVjNWJfcTR3MWdoMWhWRFZkMVk1d0tnb0JtOWRYZVp2YkplMVpfVG9rZW46U0I4QmJQZ1Njb0ZwdUR4ekVnaGNlTXZUbnJoXzE3NzEwNjEyODE6MTc3MTA2NDg4MV9WNA)

我们来对比一下`break`和`continue`：

| 特征     | break                  | continue                           |
| -------- | ---------------------- | ---------------------------------- |
| 作用     | 整个循环               | 跳过本次循环，进入下一次更新迭代   |
| 后续代码 | 不再执行循环体后续代码 | 循环体中continue之后的代码不会执行 |
| 影响范围 | 整个循环结果           | 当前这一次的循环体                 |

### 2.3三大循环中的break和continue

我们将使用具体的例子来直观的感受`break`和`continue`在循环中的作用。

#### 2.3.1while中的break和continue

- while中的break例题：

```C
#include <stdio.h>

int main()
{
    int guess_number;
    int target = 66;

    // 开启无限循环，就像一个死胡同，除非遇到 break 否则出不去
    while (1) {
        printf("请输入你猜的数字（1-100）: ");
        scanf("%d", &guess_number);

        if (guess_number == target) {
            printf("恭喜你，猜对了！\n");

            break;    // 重点：执行到这里，直接跳出整个 while 循环，去执行第 23 行
        }

        printf("猜错了，再试一次吧！\n");
    }

    printf("游戏结束，感谢游玩。\n");

    return 0;
}
```

![img](https://gcn59lcrd80x.feishu.cn/space/api/box/stream/download/asynccode/?code=ZTQ5NThjNTBkODU3NGFiMzQ4NmQxMWIzZTRlMjljNGZfUTVxSFd6eGpjN3hVbmFuclJueXBHak9lV1FVTnlBSFlfVG9rZW46SnY4M2JWNTM2b2VKYXp4RUIwdmN5SjlibmdoXzE3NzEwNjEyODE6MTc3MTA2NDg4MV9WNA)

- while中的continue例题：打印 1-10 之间的奇数

```C
#include <stdio.h>

int main()
{
    int i = 0;

    while (i < 10) {
        i++;    // 必须在 continue 之前改变变量的值，否则会死循环！

        if (i % 2 == 0) {
            continue;    // 关键点：如果是偶数，直接跳回 while(i < 10) 那一行
        }

        printf("%d 是奇数\n", i);
    }

    printf("程序运行结束。\n");

    return 0;
}
```

![img](https://gcn59lcrd80x.feishu.cn/space/api/box/stream/download/asynccode/?code=MTgwOTk1NmRmMGM2YWZlOGQ3MGY4NGU1NTc3Y2ZlNTFfWDR1STlkdkNUWFN6NVZ0bnptQVk5UjlONjRrTWhKUjJfVG9rZW46QzJxbWI1ZXBOb201U3B4WTNqaGNHQVBnbmNlXzE3NzEwNjEyODE6MTc3MTA2NDg4MV9WNA)

#### 2.3.2for中的break和continue

- for中的break例题：假设仓库里有 10 个零件，编号分别是 1 到 10。我们需要寻找编号为 **7** 的零件。一旦找到，立即停止寻找并报告位置。

```C
#include <stdio.h>

int main()
{
    int i;
    int target = 7;

    // 假设循环 10 次，代表检查 10 个货架
    for (i = 1; i <= 10; i++) {
        printf("正在检查第 %d 号货架...\n", i);

        if (i == target) {
            printf("找到了！目标在第 %d 号货架。\n", i);

            break;    // 关键点：执行到这里，直接结束整个 for 循环
        }
    }

    printf("搜索任务结束。\n");

    return 0;
}
```

![img](https://gcn59lcrd80x.feishu.cn/space/api/box/stream/download/asynccode/?code=MjZiNzQyZTAzYzE1MGViZjU4NmQ1YmJmNWUyNWNlMzZfU3pLd2thWEFKR29uWmpkbFV0VjB2NTNONmZvblcweXlfVG9rZW46WGhCT2Jqamxib3VVdXR4MWhPMGNhSTY4bkZjXzE3NzEwNjEyODE6MTc3MTA2NDg4MV9WNA)

- for中的continue例题：我们要给编号 1 到 5 的员工发奖金。但是，编号为 **3** 的员工因为表现不合格，需要被跳过（不打印他的发奖金信息），而其他员工正常发放。

```C
#include <stdio.h>

int main()
{
    int i;

    // 循环 5 次，代表 5 位员工
    for (i = 1; i <= 5; i++) {
        if (i == 3) {
            printf("员工 3 不合格，跳过发放。\n");

            continue;    // 关键点：直接跳到 i++，然后开始下一次循环判定
        }

        printf("正在为员工 %d 发放奖金...\n", i);
        printf("发放成功！\n");
    }

    printf("全公司奖金处理流程结束。\n");

    return 0;
}
```

![img](https://gcn59lcrd80x.feishu.cn/space/api/box/stream/download/asynccode/?code=N2EzNjdlMzQ0ZmNhM2RjM2E1YmNjODVhNTMzODE3NzJfTFkyN1NtRVF0aVBSSUt0dVc5MFVxb01RejYzQkdOVnRfVG9rZW46QmZabWJteHBIb3ZYQ3N4NFdua2N4akt2bmV5XzE3NzEwNjEyODE6MTc3MTA2NDg4MV9WNA)

#### 2.3.3do-while中的break和continue

- do-while中的break例题：累加器——遇到负数就停。

```C++
#include <stdio.h>

int main()
{
    int num;
    int sum = 0;

    printf("--- 欢迎使用正数累加器（输入负数停止） ---\n");

    do {
        printf("请输入一个数字: ");
        scanf("%d", &num);

        if (num < 0) {
            printf("检测到负数，正在计算结果...\n");

            break;    // 关键点：执行到这里，直接跳过 while 的条件检查，飞向第 24 行
        }

        sum = sum + num;
        printf("当前总和为: %d\n", sum);

    } while (1);    // 这里用 1 (永远成立)，全靠里面的 break 来控制生死

    printf("最终累加结果为: %d\n", sum);
    printf("感谢使用！\n");

    return 0;
}
```

![img](https://gcn59lcrd80x.feishu.cn/space/api/box/stream/download/asynccode/?code=YjNkNmViNjlmZmE2YTkyNTk0MTJiNzFmMjY3MTNhYThfQ1paOUNpQjZyZEQ1eHRDTXJiZkw4T2N6cHJuY3BPbFNfVG9rZW46WnBZTWJpQTFwb1d2WTV4djBFSmM5cG9JbjRnXzE3NzEwNjEyODE6MTc3MTA2NDg4MV9WNA)

- do-while中的continue例题：我们要从 0 数到 5。如果是 3，我们打印“跳过”并不显示数字，其他数字正常显示。

```C
#include <stdio.h>

int main()
{
    int i = 0;

    do {
        i++;    // 必须在 continue 之前改变 i 的值，防止死循环

        if (i == 3) {
            printf("跳过 3\n");

            continue;    // 关键点：直接跳到第 19 行的 while 判断处
        }

        printf("当前数字是: %d\n", i);

    } while (i < 5);

    printf("循环结束。\n");

    return 0;
}
```

![img](https://gcn59lcrd80x.feishu.cn/space/api/box/stream/download/asynccode/?code=ZWQ5YjZjYWYwNGE5Yjk0NjJkNjZiYzllOGI2ZjY1NjdfOTlnQ0pxcnRuRVBFaVkyWUhXcnY3OXpENUFDVVFlQXFfVG9rZW46TDZsUWJlUzFyb000Unp4RXUwemNDdWdkbkViXzE3NzEwNjEyODE6MTc3MTA2NDg4MV9WNA)

## 3.循环的嵌套

在前面的学习中，我们了解了三种循环，但是许多问题单靠一层循环是无法解决的，因此，我们要将三种循环彼此相互嵌套使用，从而解决更复杂的问题。

例如：

```C++
while() {
      ···;
      while() {
      ···;
      }
}

for() {
      ···;
      while() {
      ···;
      }
}

for() {
      ···;
      for() {
      ···;
      }
}

for() {
       ···;
       for() {
       ···;
           while() {
           ···;
           }
       }
}

for() {
       ···;
       while() {
       ···;
           while() {
           ···;
           }
       }
}
//略······
```

例.求e的近似值(e=1+1/1!+1/2!+1/3!+······+1/n!)(n取20)

```C++
#include <stdio.h>
int main()
{
    float e = 1;
    int i, x;
    int f;
    
    for(i = 1; i <= 20; i++) {
        f = 1;                      //为避免f重复使用,在计算阶乘前重新赋值
        for(x = 1; x <= n; x++) {
            f = f * x;
        }                           //在for循环里嵌套一个for循环用于计算阶乘
        e = e + 1.0 / f;
    }
    
    return 0;
}        
```

使用`1.0`可以将整点换为浮点类型

循环嵌套层数越多，逻辑越复杂，因此清晰界定每个循环体的作用范围十分必要，也更方便阅读和修改。

## 4.goto语句

当我们面对多层循环时，仅仅依靠`break`往往只能结束最内层的循环，想要跳出外层循环就显得力不从心。为了弥补这一点，C语言提供了`goto`语句作为一种更为直接的控制方式。

### 4.1语法格式

```C++
标识符:               // 跳转点定义    
语句;
goto 标识符;        // 跳转语句，执行后会跳转回到上面标识符的位置
```

`goto` 的使用通常包含两部分：

- 定义跳转点：使用一个标识符加冒号（:）来定义跳转点。
- 执行跳转：使用 `goto` 加上标识符名称来执行跳转。

### 4.2 执行流程

![img](https://gcn59lcrd80x.feishu.cn/space/api/box/stream/download/asynccode/?code=OWRlNDEzNTViNzM2NDUyOGFkOTI4MTFmYzk5ZjliZDBfRnFxZU9kWTNQcjRZWVlVc3A0bGl6TWlPemgxbjhuQ0FfVG9rZW46QVppZmJKb0pzb1JBd2N4M2xoa2NJZ2E1bnZmXzE3NzEwNjEyODE6MTc3MTA2NDg4MV9WNA)

**正常路径：顺序执行**

在不触发跳转的情况下，程序遵循“自上而下”的原则：

- **第一步**：执行“代码块 1”。
- **第二步**：顺着黑色箭头向下，执行“代码块 2”。
- **第三步**：继续向下，执行“代码块 3”，最后到达终点。

**跳转路径：无条件闪现**

图中红色的菱形代表了 `goto` 语句的干预：

- **触发跳转**：当程序在执行完“代码块 1”后，如果遇到 `goto 转移到标记 3` 指令。
- **无视中间层**：程序会立刻**放弃**原本该执行的“代码块 2”。图中右侧的红色连线清晰地展示了这种“跨越”。
- **精准降落**：程序直接跳转到“标记 3”所在的位置。
- **接续执行**：从“标记 3”开始，程序重新回到正常轨道，执行“代码块 3”及其之后的逻辑。

goto语句主要使用在多层循环的跳出：

```C++
#include <stdio.h>

 int main()
 {
     int i = 0, j = 0, k = 0;

     // ----------------- 三层循环 -----------------
     for (i = 0; i < 10; i++) {
         for (j = 0; j < 10; j++) {
             for (k = 0; k < 10; k++) {

                 // 当满足条件时，立即跳出所有循环
                 if (i + j + k > 15) {
                     goto end_all_loops;    // 直接跳转到标号位置
                 }

             }
         }
     }

     // 如果循环正常结束（未触发 goto），会执行这里
     printf("循环正常结束，没有触发跳转。\n");
     
     return 0;

 end_all_loops:    // 标号顶格书写，清晰标注跳转降落点
     printf("已成功跳出所有循环！\n");
     printf("当前 i = %d, j = %d, k = %d\n", i, j, k);

     return 0;
 }
```

![img](https://gcn59lcrd80x.feishu.cn/space/api/box/stream/download/asynccode/?code=YThhNjY0MGMyMmMwMzNiNDRlOWM5NThhNzdkMDVkNzFfZUh3NUUwWDFOUkNrYmpBVnVZMjZ6a1VaVmlhNjBmcHJfVG9rZW46THhKNmJoNHZmb01oMnR4Vm1XWGN5Mk8xbm5lXzE3NzEwNjEyODE6MTc3MTA2NDg4MV9WNA)

`goto`语句适用于需要一次性退出多层嵌套循环，是全局的（但受限于函数作用域）。`break`语句使用于简单的循环终止，只能跳出当前所在的单层循环，不会影响到外层的循环，是单层的。

但滥用 `goto` 会导致程序流程混乱，被称为“意大利面条代码”。因此，除非确实需要（如深层循环的错误退出），一般建议使用 `break`、`continue` 或函数返回来替代 `goto`。

## 5.综合运用

### 1.计算 1 到 100 的累加和（用while语句）。

解析：

```C++
#include <stdio.h>

 int main()
 {
     int i = 1;              // 循环变量初始化
     int sum = 0;            // 用于累加结果的变量

     // 只要 i 小于或等于 100，就继续执行循环体
     while (i <= 100) {
         sum = sum + i;      // 将当前的 i 加到 sum 中
         i++;                // 变量更新，准备下一次累加
     }

     printf("1 到 100 的累加和为: %d\n", sum);

     return 0;
 }
```

![img](https://gcn59lcrd80x.feishu.cn/space/api/box/stream/download/asynccode/?code=Mjc2MWMyYTkwMmE3ZWU4NWVlZjFiZGM4MjQ2ZDM4YTJfSGx2U3Y5d2tCRjNnanFVUmQyaThPQWF5b29TRmNabmdfVG9rZW46WHdRZ2I5NEhWb2Jkc0F4M3V0ZWNuUWV5bmtkXzE3NzEwNjEyODE6MTc3MTA2NDg4MV9WNA)

### 2.求1~20所有整数能被3整除的个数

答案:6

解析:

```C++
#include <stdio.h>
int main()
{
    int num = 0;
    int i;
    
    for(i = 1; i <= 20; i++) {
        if(i % 3 != 0)
        {
            continue;
            //使用continue直接跳过不需要的数字
        }
        else {
            num++;
        }
    }
    printf("1~20所有整数不能被3整除的个数为%d", num);
    
    return 0;
}
```

![img](https://gcn59lcrd80x.feishu.cn/space/api/box/stream/download/asynccode/?code=ZmFhNzg2YzJiYjY4NGM1NjNhZTVkM2MxNzRiNDIzMjhfYUR2WHpvV29jampHS1ZWNkJrZXIyNXEzalRFbjNVeU1fVG9rZW46QmpHd2JIbk4yb2lSNTJ4V29wWWNQQ0xobm5lXzE3NzEwNjEyODE6MTc3MTA2NDg4MV9WNA)

### 3.输出2~200素数的个数

解析:

```C++
#include <stdio.h>
int main()
{
        int i, x, num = 0;
        
        for(x = 2; x <= 200; x++)           
        {         
                //外层循环:2~200每个数进行素数判断                      
                for(i = 2;i <= x-1;i++)
                {     
                //内层循环:判断是否是素数                   
                        if(x % i == 0)
                        {
                                break; 
                //若有一个因子,可以直接break语句跳出循环,节省时间              
                        }
                }
                //若从2~i-1都不是因子,这个数就是素数,x会再进行一次x++
                if(i == x)               
                {
                        num++;
                }
        }
        printf("一共有%d个", num);
 } 
```

**为什么用if(i == x)进行num(个数的增加)?**

for循环的执行原理是在一次循环结束的时候先`更新迭代`一次，再进行条件的判断

回到题目中，假设x = 3,明显3是素数,内层i=2就无法满足if语句,此时会`再进行一次i++`,进行后i=3>x,虽然不会再进入内循环，但是i的值已经变成了3

![img](https://gcn59lcrd80x.feishu.cn/space/api/box/stream/download/asynccode/?code=MTY4OTYxOWExNjViZDk3N2ZmNTBmZmM5MmI1NGNjYWJfQk1JMHNsaFFZcUJOQk9BWThrMEx1b2FSMlR1czZGOFpfVG9rZW46WGJKN2IzdmxnbzJoSDR4SHVFQWNuT0pKbllZXzE3NzEwNjEyODE6MTc3MTA2NDg4MV9WNA)

### 4.输入两个整数，求它们的最小公倍数和最大公约数

解析:

```C++
#include <stdio.h>
int main()
{
    int x, y;
    int i;
    scanf("%d %d", &x, &y);
    //第一个循环用于寻找最小公倍数
    for(i = x; i <= x * y; i++) {
        if(i % x == 0 && i % y == 0) {
            printf("%d和%d的最小公倍数为%d\n", x, y, i);
            break;
     //使用break语句结束循环，避免重复输出
        }
    }
    //第二个循环用于寻找最大公约数
    for(i = x; i >= 1; i--) {
        if(x % i == 0 && y % i == 0) {
            printf("%d和%d的最大公约数为%d\n", x, y, i);
            break;
    //使用break语句结束循环，避免重复输出
        }
    }
    return 0;
}
```

![img](https://gcn59lcrd80x.feishu.cn/space/api/box/stream/download/asynccode/?code=NzAyYjNhZjIyNTUzYmU5ZmM3MWIxMmFmZmUxZjkwY2RfNmRpMDZxWWF4ZTdkSmw4Y1lMWWo3ZnRXZGVnc0NXZTFfVG9rZW46SzdCd2I2NEhhb3hxZFF4VkczMmNvbXBXbjdlXzE3NzEwNjEyODE6MTc3MTA2NDg4MV9WNA)

寻找最小公倍数:假设输入的数为x = 128, y = 512

- 起始点：从x,y任意一个数开始(x,y的相对大小对代码运算无影响)
- 终止点：遍历至两数乘积为止（`x * y`）
- 判断条件：检查当前数是否能同时被两数整除
- 结果输出：找到第一个满足条件的数即为最小公倍数
- 循环终止：使用 `break` 语句在找到结果后立即退出循环

寻找最大公约数:同样是x = 128, y = 512

- 起始点：从x,y任意一个数开始(x,y的相对大小对代码运算无影响)
- 终止点：遍历至最小因子1
- 判断条件：检查当前数是否能同时被两数整除
- 结果输出：找到第一个满足条件的数即为最大公约数
- 循环终止：使用 `break` 语句在找到结果后立即退出循环

### 5.打印输出100~999所有的三位水仙花数（是指一个 3 位正整数，其各个位上的数字的 3 次幂之和等于该数本身。）

```C++
#include <stdio.h>
#include <math.h>
int main()
{
    int x;
    int a, b, c;
    
    for(x = 100; x < 1000; x++) {
        a = x / 100;
        //对100求商可得百位数字       
        b = x % 100 / 10;
        //对100求余后再对10求商可得十位数字
        c = x % 10;
        //对10求余可得个位数字
        if(pow(a, 3) + pow(b, 3) + pow(c, 3) == x) {
            printf("%d\n", x);
        }
        //满足条件后后输出
    }
    
    return 0;
}        
```

![img](https://gcn59lcrd80x.feishu.cn/space/api/box/stream/download/asynccode/?code=MWI2MDQ4OGNiOWM5ZDE3ZDcyYmZiMjY5MGZmOTZiZjZfamU4cjBlRGhla3dweWtCWGE3OEp3aWtlcDFtSndZZXVfVG9rZW46WmMxa2JPc2FUb2tLU0l4TjVXN2NsQ3d6bkRoXzE3NzEwNjEyODE6MTc3MTA2NDg4MV9WNA)

因为a,b,c都是整点类型所以例如`a = 101 ``/ 100`会得到`a = 1`而非1.01。

### 6.用户输入数字，直到输入 0 结束，并统计输入了多少个非零数字。

```C++
#include <stdio.h>

 int main()
 {
     int num;                // 用于接收用户输入的数字
     int count = 0;          // 用于统计非零数字个数的计数器

     printf("请输入数字（输入 0 结束统计）:\n");

     do {
         scanf("%d", &num);

         // 如果输入的不是 0，则计数器加 1
         if (num != 0) {
             count++;
         }

     } while (num != 0);     // 只要输入的不是 0，就继续循环

     printf("您一共输入了 %d 个非零数字。\n", count);

     return 0;
 }
```

![img](https://gcn59lcrd80x.feishu.cn/space/api/box/stream/download/asynccode/?code=ZWY2OTQ5M2VhYjg4Y2ZmMGE3MTg4MTU1Yzk1MTA5ZTZfVXZsU0tsbVRDYzV1QnlQMUQ3TEh2M0dBYVJ6enJpTVpfVG9rZW46WlA1R2JoWW9ub0JjNDl4dmliN2NqaXM3bmJkXzE3NzEwNjEyODE6MTc3MTA2NDg4MV9WNA)

**为什么选择** **`do-while`****？**

- 在普通的 `while` 循环中，如果一开始条件不成立，循环体一次都不会执行。
- 但在本题中，我们**必须**让用户先输入（执行循环体内容），程序才能拿到数字进行判断。`do-while` 这种“先斩后奏”的特性完美契合此场景。

我们在循环内部加了一个 `if (num != 0)` 判断，确保只有在用户输入有效数字时才加 1，而最后的那个“结束标志” 0 不会被计入总数。

### 7.打印一个 5 * 5 的星号*矩形

```C
#include <stdio.h>

 int main()
 {
     int row;    // 行计数器
     int col;    // 列计数器

     // 外层循环控制行数：总共打印 5 行
     for (row = 1; row <= 5; row++) {
         
         // 内层循环控制每行打印的列数：每行打印 5 个星号
         for (col = 1; col <= 5; col++) {
             printf("* ");
         }

         // 每一行（内层循环）打印完毕后，必须执行换行
         printf("\n");
     }

     return 0;
 }
```

![img](https://gcn59lcrd80x.feishu.cn/space/api/box/stream/download/asynccode/?code=ODlkNjg0MjAyMTM4ZDhmY2IxOTEyNTgyOTdkMjNhMmZfWHNjaEFPSGdJbmFGQVVyTHNvcTd3aURpR3dOZndOSmZfVG9rZW46SEVXVGI2WTJFb1NGdkV4U2ZvbWN4UnBmbkJoXzE3NzEwNjEyODE6MTc3MTA2NDg4MV9WNA)

**外层循环 (****`row`****)**：负责纵向移动。它每执行一次，程序就会产生新的一行。

**内层循环 (****`col`****)**：负责横向排列。在外层循环执行 1 次的过程中，内层循环会完整地跑完 5 次，从而在同一行打印出 5 个星号

`printf("\n");` 的位置至关重要。它必须放在内层循环**结束之后**、外层循环**结束之前**。这意味着：“等这一行的 5 个星号都排好了，再命令光标跳到下一行”。

它们分别是`3`，`6`，`9`，`12`，`15`，`18`

### 8.打印九九乘法表

解析：

```C++
#include <stdio.h>

 int main()
 {
     int row;    // 行变量
     int col;    // 列变量

     // 外层循环控制行数，从 1 到 9
     for (row = 1; row <= 9; row++) {
         
         // 内层循环控制每一行的列数
         // 注意：列数 col 永远小于或等于当前的行数 row
         for (col = 1; col <= row; col++) {
             printf("%d * %d = %-2d  ", col, row, col * row);
         }

         // 每一行打印完后，需要换行进入下一行
         printf("\n");
     }

     return 0;
 }
```

![img](https://gcn59lcrd80x.feishu.cn/space/api/box/stream/download/asynccode/?code=Mzc2ZjRmMjBiNTQ3YTg4ZjU2YzM5NjhmZGMwY2Q0ZjBfVnVtU3BraHgzNHd5SkhsbWlTWDZwSzUwaTJHd05SZVdfVG9rZW46TkJXVGI4d0tZb1VwUjJ4Q2g1cWNkZzYxbmhjXzE3NzEwNjEyODE6MTc3MTA2NDg4MV9WNA)

**外层循环（row）**：决定了乘法表的“高度”。它跑一圈，代表我们要开始写新的一行了。

**内层循环（col）**：决定了每一行的“长度”。

**`col <= row`**：

- 这是最容易出错的地方。九九乘法表是三角形的，第一行只有 1 个式子，第二行有 2 个。
- 这意味着：内层循环的终点不是固定的 9，而是**当前的行号**。

`%-2d` 是一个小技巧，表示左对齐并占 2 个字符宽。这能保证即使乘积是一位数或两位数，表格也能对齐得非常美观。

### 9.在三层嵌套循环中寻找一个解，一旦找到，使用 `goto` 一键跳出所有循环。

```C
#include <stdio.h>

 int main()
 {
     int i = 0, j = 0, k = 0;
     int target = 15;    // 设定寻找的目标：三个数之和等于 15

     // ----------------- 三层嵌套寻找目标 -----------------
     for (i = 1; i <= 10; i++) {
         for (j = 1; j <= 10; j++) {
             for (k = 1; k <= 10; k++) {

                 // 检查当前组合是否满足条件
                 if (i + j + k == target) {
                     printf("成功找到目标组合：i=%d, j=%d, k=%d\n", i, j, k);
                     
                     goto find_target;    // 发现目标，立即跳出所有嵌套循环
                 }

             }
         }
     }

     // 如果循环全部跑完都没有触发 goto，会执行这里
     printf("未能在范围内找到符合条件的解。\n");
     return 0;

 find_target:    // 标号顶格书写，清晰标注跳转降落点
     printf("--- 搜索程序已通过 goto 成功退出 ---\n");

     return 0;
 }
```

![img](https://gcn59lcrd80x.feishu.cn/space/api/box/stream/download/asynccode/?code=ZTJiMDBhODMxYjg1YTc2ZjU2ODU1NTMxN2EyNTI2MDdfQTBJaWpKeUVac2lxc3hLeGQzMTBpM0hieXpTeHJ3b1pfVG9rZW46TmRLWmJrOEZJbzFXV0J4cDJubGMzRExkblJiXzE3NzEwNjEyODE6MTc3MTA2NDg4MV9WNA)

**执行效率与简洁度**：如果使用 `break`，必须在每一层循环都加上一个 `if` 判断来检查是否要继续退出。而使用 `goto`，程序会无视所有大括号的阻碍，直接从最内层“闪现”到指定的标号处。

**执行顺序**：程序运行到 `goto` 时，会跳过其下方直到标号之间的所有代码（包括那些 `for` 循环剩下的部分和中间的打印语句）。

虽然 `goto` 强大，但也要告诉读者：只有在处理这种**深层嵌套退出**或**错误处理**时才推荐使用。漫无目的地乱跳会破坏程序的逻辑结构。