# 指针

**什么是指针？**

指针是存储其他变量内存地址的变量。为了帮助理解，可以把指针想象成一个“地址条”，它并不存储具体的数值，而是存储指向某个位置（内存地址）的“地址”。

- 比喻：假设你住在一个城市，而指针就是你家门牌号。门牌号本身不存储你家的具体信息（比如家里的物品），它只是指向你家的位置。你可以通过这个“门牌号”找到你家。

**指针的声明**

指针的声明非常简单，只是加上一个星号 `*`，来表示这个变量是一个指针。

- **语法**：

```C
数据类型 *指针名;
```

- 例如：

```C
int *p;
```

- 这里，`p` 是一个指向 `int` 类型的指针，它可以存储任何整数变量的地址。

## 1.地址与指针变量

### 1.1地址

##### 什么是“地址”？

> **地址 = 变量在****内存****中的位置编号**

就像现实世界中：房子有**门牌号**、书在图书馆里有**书架编号**、人在学校有**学号**；

**地址**，就是 **计算机用来找到某一块****内存****的编号**。

若要从“内存”说起，那么我们要先了解什么是内存？你可以把 **内存（****RAM****）** 想象成一排排连续的小格子：

```YAML
内存：| 格子 | 格子 | 格子 | 格子 | 格子 | ...
编号： 1000  1001  1002  1003  1004
```

- 每个小格子都有一个**唯一编号**
- 这个编号，就是 **内存地址**

在了解完地址后，下面我们来学习两种新的符号：**地址符与解引用符**

- **地址符** **`&`**：获取变量的内存地址。例如，如果 `a` 是一个整数变量，`&a` 就是 `a` 的内存地址。

```C
int a = 10;
int *p = &a;  // p 存储了 a 的地址
```

- **解引用符** **`\*`**：通过指针访问内存中的值。`*p` 表示访问 `p` 所指向地址中的值。

```C
printf("%d", *p);  // 输出 p 所指向地址的值，即 a 的值 10
```

### 1.2指针变量

前面我们已经介绍了指针，那么接下来让我们更深入的了解一下**指针变量**以及它和**指针**有什么区别。

> **指针变量：用来存储“地址”的变量**

注意三个关键词：

- **变量** 
- **存储的不是普通数据** 
- **存储的是内存地址** 

为什么要有“指针变量”？我们先想一个问题：普通变量能不能存地址？

```C
int a = 10;
```

- `a` 只能存 **10**
- 它不能存 `&a`

那如果我们**想保存一个地址**呢? 所以就需要一种**专门用来存地址的变量**,这就是：**指针变量**。

#####  指针变量的声明

```C
int *p;
```

读法是：

> **p 是一个“指向 int 的指针变量”**

##### 指针变量到底“存”的是什么？

看完整过程：

```C
int a = 10;
int *p = &a;
```

内存示意（假设）：

```YAML
地址      内容
1000  ->  10      ← a
2000  ->  1000    ← p
```

 

**关键结论**：

> **指针变量存的是：另一个变量的地址**

在前面我们提到了指针这一概念但我们应切记：**指针变量 ≠ 指针**

很多初学者会混，这里必须说清楚：

- **指针**：一种概念（地址）
- **指针变量**：装地址的变量

就像：

## 2.指针与数组

### 2.1指针与数组的关系

#### **2.1.1数组作为指针**

数组名本质上是一个指向数组第一个元素的指针。因此，数组和指针是紧密关联的。

- 比喻：假设你有一个存放多个物品的盒子，盒子的名字就是指向第一个物品的“地址条”。你通过这个“地址条”就能访问盒子里的所有物品。

例如，以下代码通过指针遍历数组：

```C
#include<stdio.h>
int main()
{
    int arr[5] = {1, 2, 3, 4, 5};
    int *p = arr;  // p 指向数组的第一个元素
    
    printf("%d", *(p + 2));  // 输出 arr[2]，即 3
    
    return 0；
}
```

这里，`arr` 就是数组名，它实际上指向数组的第一个元素 `arr[0]`。而 `p + 2` 就是访问数组中的第三个元素。

#### **2.1.2指针与数组下标的关系**

我们可以通过指针来访问数组的元素，这与通过下标访问数组是一样的。

```C
printf("%d", *(arr + 2));  // 等价于 arr[2]
```

这段代码通过指针算出偏移量，访问数组中的第三个元素 `arr[2]`。

### 2.2数组名

在前面的**数组与结构体**章节我们已经学习了什么是**数组**，却没有详细解释**数组名**这一概念，因此在这里我们先给一个结论：

> **数组名，本质上是“指向数组第一个元素的指针常量”**

拆开解释：

- 是 **指针** 
- 指向 **首元素** 
- 不能改指向（不是普通指针变量）

#### 用代码看数组在内存中的样子

```C
int arr[3] = {10, 20, 30};
```

内存示意（假设）：

```CSS
地址      内容
1000  ->  10   arr[0]
1004  ->  20   arr[1]
1008  ->  30   arr[2]
```

| 表达式  | 含义                   |
| ------- | ---------------------- |
| arr     | 数组首元素地址（1000） |
| &arr[0] | 数组首元素地址（1000） |
| arr[0]  | 第一个元素的值（10）   |

 **结论**：

```C
arr == &arr[0]   // 成立
```

### 2.3算数指针

#### 2.3.1 什么是算术指针？

**算术指针**指的是：

> **对指针进行加、减、自增、自减等运算**

 不是对“指针指向的值”运算，而是对**地址位置**运算。

#### 2.3.2 指针 + 1 到底是什么意思

> **指针 + 1 = 向后移动一个“它所指向类型”的大小**

不是简单加 1 个字节。

#### 2.3.3 int 指针算术示例

```C
int arr[3] = {10, 20, 30};
int *p = arr;
```

内存：

```CSS
p      → 1000
p + 1  → 1004
p + 2  → 1008
```

因为：

- `int` 占 4 字节
- 所以每次移动 4 个字节

### 2.4指针与字符数组

#### 2.4.1 字符数组与指针的关系

在 C 语言中，**字符数组名**（`str`）实际上就是指向数组首元素的**常量指针**。

- **数组名** **`str`** **等价于** **`&str[0]`**，指向第一个字符的地址。
- 数组名 `str` 作为指针常量，**不能改变它所指向的地址**。

##### 示例

```C
char str[] = "hello";
```

此时：`str` 是指向数组 `str` 第一个元素 `'h'` 的指针，存储着 `1000`（假设）这个地址。

​          数组名 `str` **不可改变**，不能指向别的地方。

#### 2.4.2 **指针与字符数组的互换使用**

**字符数组**与**字符指针**非常紧密，**数组名本质上是指针**，所以它们经常可以互换使用。

**等价示例**：

```C
char str[] = "hello";   // 字符数组
char *p = str;          // 字符指针指向数组的首元素
```

- `str` 和 `p` 都指向同一个位置，也就是字符串 `"hello"` 的首字符 `'h'`。

#### 2.4.3 **字符数组作为字符串容器**

C 语言没有内建的字符串类型，所有字符串其实都是字符数组。**字符数组的末尾必须以** **`'\0'`** **结尾**，否则相关的字符串操作函数（如 `printf`、`strlen` 等）无法正确识别字符串的结束。

为什么要有 `'\0'`？

- `'\0'` 标记了字符串的**结束位置**。没有它，`printf` 就无法知道何时停止打印字符，可能导致**内存溢出**等错误。

```C
char str[10] = "hello";  // 预留了 10 字节空间
printf("%s", str);       // 输出 "hello"
```

- 数组的空间足够存储字符串 `"hello"` 和 `'\0'`，总共 6 字节。
- 即使预留了更多空间（例如 10 字节），数组的**有效内容**依然是 `"hello"` + `'\0'`。

#### 2.4.4 如何通过指针操作字符串

可以通过指针访问和修改字符串中的字符。举个例子：

```C
#include<stdio.h>
int main(){
    char str[] = "hello";
    char *p = str;
    printf("%c\n", *p);   // 输出 'h'
    p++;                  // 移动到下一个字符
    printf("%c\n", *p);   // 输出 'e'
}
```

- `*p` 解引用指针，得到指向的字符。
- `p++` 使指针指向下一个字符。

#### 2.4.5 通过指针遍历字符串

使用指针遍历字符串是一种常见的操作。我们可以通过指针逐个字符地访问数组，直到遇到 `'\0'`。

```C
#include<stdio.h>
int main(){
char str[] = "hello";
char *p = str;

while (*p != '\0') {
    printf("%c", *p);
    p++;
}

}
```

输出：

```Nginx
hello
```

- `*p` 打印字符
- `p++` 移动到下一个字符

## 3.const与指针

`const` 关键字是 C 语言中的一个重要概念，主要用于声明常量（不可修改的值）。但是，`const` 和指针结合时，很多初学者可能会感到困惑。指针的本质是存储**内存地址**，而通过 `const` 的修饰，我们可以控制指针所指向的数据是否可修改，以及指针本身是否可以修改其指向的地址。本小节将深入解析 `const` 与指针的各种组合方式，以及它们的实际应用。

### 3.1 `const` 修饰数据（常量数据）

#### 3.1.1 基本定义

当 `const` 修饰一个数据时，表示该数据一旦被初始化后，其值不能再修改。

```C
const int x = 10;
```

- `x` 是一个常量，它的值为 `10`，并且不能在程序的其他地方修改。

#### 3.1.2 `const` 修饰常量的行为

- `const` 修饰的数据只能在定义时初始化，之后无法再更改。
- 编译器会强制你遵守这一限制，任何修改常量的尝试都会引发编译错误。

```C
const int x = 10;
x = 20;  // 错误：常量 x 不能修改
```

#### 3.1.3 常量的好处

使用 `const` 可以增加代码的可维护性和安全性，防止意外修改某些值，尤其在函数参数中使用常量可以保证传递的值不被修改。

### 3.2`const` 修饰指针（指针常量）

#### 3.2.1 `const` 修饰指针

`const` 关键字不仅可以修饰数据，还可以修饰指针，表示指针所指向的数据不能被修改，或者指针本身不能指向其他位置。如果 `const` 修饰的是指针指向的内容，意味着指针所指向的内容不能修改，但指针可以改变它所指向的地址。

```C
const int *p = &x;
```

- `p` 是一个指向常量整数的指针。
- `p` 可以指向不同的地址，但不能修改它指向的地址内容。

##### 举例：

```C
int x = 10, y = 20;
const int *p = &x;  // p 指向 x

*p = 30;  // 错误：不能修改 *p 指向的数据
p = &y;   // 正确：可以改变指针 p 指向的地址
```

在上面的代码中，`*p = 30` 会导致编译错误，因为 `*p` 是常量，它指向的数据不能被修改。而 `p = &y` 是允许的，指针 `p` 可以指向 `y`。

#### 3.2.2 `const` 修饰指针本身（指针常量）

如果 `const` 修饰的是指针本身，表示指针的地址不能改变，它始终指向同一块内存。

```C
int x = 10, y = 20;
int * const p = &x;
```

- `p` 是一个常量指针，它始终指向 `x`，不能改变指向其他地址。
- 但是可以通过 `*p` 修改指针所指向的数据。

##### 举例：

```C
int x = 10, y = 20;
int * const p = &x;  // p 是指向 x 的常量指针

*p = 30;  // 正确：可以修改 p 指向的数据
p = &y;   // 错误：不能修改 p 的指向
```

在上面的代码中，`*p = 30` 是允许的，因为常量指针 `p` 只是不能改变其指向的地址，但可以修改它指向的内容。而 `p = &y` 会导致编译错误，因为 `p` 是常量指针，不能重新指向 `y`。

### 3.3 `const` 与指针的组合

### 3.3.1 `const` 修饰指针本身和指针指向的数据

有时我们可能想要创建一个指向常量数据的常量指针。通过 `const` 可以实现这一点。

```C
const int * const p = &x;
```

- `p` 是一个常量指针，它指向常量数据。
- `p` 不能指向其他地址，并且不能修改它所指向的内容。

#####  举例：

```C
int x = 10, y = 20;
const int * const p = &x;  // p 是常量指针，指向常量数据

*p = 30;  // 错误：不能修改 p 指向的数据
p = &y;   // 错误：不能修改 p 的指向
```

在这个例子中，`*p = 30` 和 `p = &y` 都是错误的，因为 `p` 既是常量指针，又是指向常量数据的指针，既不能修改指针指向的数据，也不能修改指针本身。

#### 3.3.2 `const` 指针在函数中的应用

`const` 修饰指针时，可以用于保证函数参数在执行过程中不被修改。常用于函数参数传递中，以确保传递的值保持不变。

```C
void printValue(const int *p) {
    printf("Value: %d\n", *p);
    // *p = 10;  // 错误：不能修改 p 指向的数据
}
```

通过 `const` 修饰指针，可以使函数内部不能修改指针指向的数据，增加代码的安全性。

## 4.指针与结构体

在 C 语言中，**结构体**是用于将不同类型的变量组合在一起的复杂数据类型，而 **指针** 是存储内存地址的变量。指针和结构体结合的使用，使得我们能够通过指针访问和操作结构体成员，提高了程序的灵活性和效率。接下来我们将通过代码示例，详细讲解如何在 C 语言中使用指针操作结构体。

### **4.1结构体的基本定义与初始化**

前面我们已经学习了结构体的基本内容，为方便接下来我们能更好的理解**指针与结构体**的内容，现在让我们来回顾一下。结构体是 C 语言中一种用户自定义的数据类型，它能够将不同类型的数据组合成一个单一的实体。结构体的定义通常包含多个不同类型的数据成员。

```C
#include <stdio.h>
#include <string.h>  // 用于字符串操作

// 定义结构体
struct Person {char name[50];  // 字符串，存储名字
    int age;                   // 整型，存储年龄
    float height;              // 浮点型，存储身高
};

int main() {
    // 初始化结构体变量
    struct Person person1 = {"John", 30, 5.9};
    // 打印结构体成员
    printf("Name: %s\n", person1.name);printf("Age: %d\n", person1.age);printf("Height: %.2f\n", person1.height);
return 0;
}
```

- `struct Person` 定义了一个结构体类型 `Person`，包含了三个成员：`name`（名字）、`age`（年龄）和 `height`（身高）。
- 在 `main()` 函数中，我们通过 `person1` 创建了一个结构体变量，并初始化了它的值。
- 使用 `printf` 打印结构体成员时，我们通过点运算符 `.` 来访问每个成员。

### **4.2指向结构体的指针**

指针不仅能指向普通数据类型，还能指向结构体类型。指向结构体的指针可以通过解引用（`*`）来访问结构体的成员。

```C
#include <stdio.h>
#include <string.h>  // 用于字符串操作

// 定义结构体
struct Person {char name[50];  // 字符串，存储名字
    int age;        // 整型，存储年龄
    float height;   // 浮点型，存储身高
};

int main() {
    // 初始化结构体变量
    struct Person person1 = {"John", 30, 5.9};
    
    // 声明指向结构体的指针
    struct Person *ptr = &person1;  // 指针 ptr 指向 person1

    // 使用指针访问结构体成员
    printf("Name: %s\n", ptr->name);  // 使用箭头运算符访问成员
    printf("Age: %d\n", ptr->age);printf("Height: %.2f\n", ptr->height);
return 0;
}
```

- 在代码中，我们声明了一个指向 `Person` 结构体的指针 `ptr`，并将其指向 `person1`。
- 使用箭头运算符 `->`，可以通过指针访问结构体的成员，这比使用 `(*ptr).name` 更为简洁。
- `ptr->name` 等价于 `(*ptr).name`，通过指针访问结构体的成员。

### **4.3通过指针传递结构体**

指针作为函数参数，可以用来传递结构体的地址，避免传递结构体副本的开销。通过指针传递结构体，函数可以直接修改原结构体的内容。

```C
#include <stdio.h>
#include <string.h>  // 用于字符串操作

// 定义结构体
struct Person {char name[50];  // 字符串，存储名字
    int age;        // 整型，存储年龄
    float height;   // 浮点型，存储身高
};

// 函数接受指向结构体的指针
void printPerson(struct Person *p) {
    // 通过指针访问结构体成员
    printf("Name: %s\n", p->name);
    printf("Age: %d\n", p->age);
    printf("Height: %.2f\n", p->height);
}

int main() {
    // 初始化结构体变量
    struct Person person1 = {"Alice", 28, 5.5};
    
    // 传递指向结构体的指针
    printPerson(&person1);
    
    return 0;
}
```

- `printPerson()` 函数接受一个指向 `Person` 结构体的指针作为参数。
- 通过指针，我们能够访问并打印结构体的成员。函数内部修改的就是传递的结构体原本的数据。
- 使用指针传递结构体相比传递结构体本身更加高效，尤其在结构体较大时。

### **4.4结构体数组与指针结合**

结构体数组存储多个结构体元素。通过指针可以遍历结构体数组，访问其中的每个元素。

```C
#include <stdio.h>
#include <string.h>  // 用于字符串操作

// 定义结构体
struct Person {
    char name[50];  // 字符串，存储名字
    int age;        // 整型，存储年龄
    float height;   // 浮点型，存储身高
};

int main() {
    // 初始化结构体数组
    struct Person people[3] = {
        {"John", 30, 5.9},
        {"Alice", 28, 5.5},
        {"Bob", 35, 6.1}
    };
    // 声明指向结构体的指针
    struct Person *ptr = people;  // 指向数组的第一个元素

    // 使用指针访问结构体数组成员
    for (int i = 0; i < 3; i++) {
    printf("Name: %s, Age: %d, Height: %.2f\n", ptr[i].name, ptr[i].age, ptr[i].height);
    }
    
    return 0;
}
```

- `people` 是一个 `Person` 类型的结构体数组，包含 3 个元素。
- `ptr` 是指向 `Person` 类型的指针，指向结构体数组 `people` 的第一个元素。
- 使用指针遍历结构体数组，访问每个结构体的成员。

### **4.5指针与结构体的传递：指针常量**

指针常量是指指针本身不可修改，但它指向的内容可以修改。这种方式在保护指针地址不被修改的同时，允许修改指向的数据。

```C
#include <stdio.h>

// 定义结构体
struct Person {
    char name[50];  // 字符串，存储名字
    int age;        // 整型，存储年龄
    float height;   // 浮点型，存储身高
};

// 函数接受指向常量数据的常量指针
void modifyPerson(const struct Person * const p) {
    // p->age = 40;  // 错误：不能修改常量指针指向的数据
    printf("Name: %s\n", p->name);
    printf("Age: %d\n", p->age);
    printf("Height: %.2f\n", p->height);
}

int main() {struct Person person1 = {"John", 30, 5.9};

    // 传递指向常量的常量指针
    modifyPerson(&person1);
    return 0;
}
```

- `const` 关键字保证了函数内部不能修改指针所指向的数据，同时指针 `p` 也无法指向其他位置。

## 5.综合运用

### 1.声明一个整数变量，并通过指针访问并修改该变量的值。

解析：

```C
#include <stdio.h>

int main() {
    int a = 10;
    int *p = &a;  // 定义指向a的指针

    // 通过指针修改a的值
    *p = 20;
    printf("Value of a: %d\n", a);  // 输出 a 的值
    return 0;
}
```

![img](https://gcn59lcrd80x.feishu.cn/space/api/box/stream/download/asynccode/?code=YzljMjlmYjA5ODhhNTgxY2ViMjBjMDQwNTQyN2EwNWZfNUoxdmZ0WlhtdHJCbzNRYWdjNWo2SzZMSVZtb3ZyaElfVG9rZW46Ukl0RmJnQ2pub1Qza3N4MzJleWNjaWR0blR2XzE3NzEwNjEzMTQ6MTc3MTA2NDkxNF9WNA)

### 2.定义一个整数数组，通过指针访问并打印数组的所有元素。

解析：

```C
#include <stdio.h>

int main() {
    int arr[3] = {1, 2, 3};
    int *p = arr;  // 数组名即为指向数组首元素的指针

    // 使用指针遍历数组
    for (int i = 0; i < 3; i++) {
        printf("Element %d: %d\n", i, *(p + i));
    }
    return 0;
}
```

![img](https://gcn59lcrd80x.feishu.cn/space/api/box/stream/download/asynccode/?code=MzE0YTdjZWMyMTAwN2Y5YTYxYTBhMzY3N2I2Y2U3MGRfcFhDcm9NZlpuckNNc0ZuS3ZvMHFKdXZUR2h1T3czV3pfVG9rZW46WTF0ZWJmTVlCb3lZRUh4djZIRGMyY3FIbk9iXzE3NzEwNjEzMTQ6MTc3MTA2NDkxNF9WNA)

### **3.**声明一个字符串，并通过指针逐字符打印字符串。

解析：

```C
#include <stdio.h>

int main() {
    char str[] = "Hello";
    char *p = str;  // 指向字符串的指针

    // 逐字符打印字符串
    while (*p != '\0') {
        printf("%c", *p);
        p++;  // 移动指针到下一个字符
    }
    printf("\n");
    return 0;
}
```

![img](https://gcn59lcrd80x.feishu.cn/space/api/box/stream/download/asynccode/?code=NDU3ZTJmODEyYWRiYTAyN2MwYWYyODkxMzViODM4Y2JfUlFxd3pCVEtsbXNlT1I0R0xDa2pqQk44UHBOMjAzS2VfVG9rZW46RHFUZGJubEpZb2JaUDd4bE1RcGN6MG9qbjBjXzE3NzEwNjEzMTQ6MTc3MTA2NDkxNF9WNA)

### 4.定义一个结构体 `Person`，并通过指针访问结构体的成员。

解析：

```C
#include <stdio.h>

struct Person {
    char name[50];
    int age;
};

int main() {
    struct Person person = {"John", 25};
    struct Person *p = &person;
    
    // 通过指针访问结构体成员
    printf("Name: %s\n", p->name);
    printf("Age: %d\n", p->age);
    return 0;
}
```

![img](https://gcn59lcrd80x.feishu.cn/space/api/box/stream/download/asynccode/?code=NWY2MjRkNWY5NGU4MjdiYmQ4NWE4M2E4ZTYxMDcwYzhfMFpmdHZ6aVBKcmdBeHc4RjYxMDg3MlVBQnc4UUo5S3lfVG9rZW46TjJwRGJweHNLb0dhdzR4cHNOa2NrSkxCbkdoXzE3NzEwNjEzMTQ6MTc3MTA2NDkxNF9WNA)

### 5.定义一个结构体 `Person`，通过指针传递结构体并修改结构体成员。

解析：

```C
#include <stdio.h>

struct Person {
    char name[50];
    int age;
};

void modifyPerson(struct Person *p) {
    p->age = 30;  // 修改指针指向的结构体成员
}

int main() {
    struct Person person = {"Alice", 25};
    
    printf("Before modification: Age = %d\n", person.age);
    
    modifyPerson(&person);  // 通过指针传递结构体

    printf("After modification: Age = %d\n", person.age);
    
    return 0;
}
```

![img](https://gcn59lcrd80x.feishu.cn/space/api/box/stream/download/asynccode/?code=ODkwZDg4NTE3NTdlOTliZTIxMmViYzRlMzQwMTA5YTNfaEN2VEtYTVBJdEhJa3pXaVJjTWZNb0U3eFYxTEhlN0VfVG9rZW46QUZEb2JZSHo2b0xWRDh4Vm1aWGN3UzVIbmZmXzE3NzEwNjEzMTQ6MTc3MTA2NDkxNF9WNA)

### 6.定义一个结构体数组，通过指针遍历数组并打印每个结构体成员。

解析：

```C
#include <stdio.h>

struct Person {
    char name[50];
    int age;
};

int main() {
    struct Person people[3] = {
        {"John", 30},
        {"Alice", 28},
        {"Bob", 35}
    };
// 使用指针遍历结构体数组
    struct Person *p = people;
    for (int i = 0; i < 3; i++) {
    printf("Name: %s, Age: %d\n", p[i].name, p[i].age);
    }
    
    return 0;
}
```

![img](https://gcn59lcrd80x.feishu.cn/space/api/box/stream/download/asynccode/?code=MDM1MzU5NWI2MjEzNTZiNDRlYTNjOWM5MDRmMzI3N2FfWVpkSUNmV1U4OXNLcW01WGxQZzFNc2tyb1dhaUpiNXFfVG9rZW46RzJYZ2J5ZkNub1lWdnJ4ZGh3RGNGcG1nbnhjXzE3NzEwNjEzMTQ6MTc3MTA2NDkxNF9WNA)

### 7.定义常量指针和指针常量，并演示它们的不同使用方式。

解析：

```C
#include <stdio.h>

int main() {
    int a = 10, b = 20;
    // 常量指针
    int *const ptr1 = &a;
    // ptr1 = &b;  // 错误：指针常量不能修改指向
    *ptr1 = 15;  // 正确：可以修改指针所指向的内容
    printf("ptr1 points to value: %d\n", *ptr1);
    // 指针常量
    const int *ptr2 = &a;
    ptr2 = &b;  // 正确：可以修改指针指向的内容
    // *ptr2 = 25;  // 错误：不能修改指针所指向的内容
    printf("ptr2 points to value: %d\n", *ptr2);
    
    return 0;
}
```

![img](https://gcn59lcrd80x.feishu.cn/space/api/box/stream/download/asynccode/?code=MzNjOWUzMDM1ZGZhYTQxODQwZDQxOTQwM2YyZmNkNzdfSkZPQzY1aWdrVlpKQ0NaNk5NZUx4SDNuQmNRZGNvODRfVG9rZW46Q0w4ZmJXeFQyb1dJWXp4T3I2WGNpelBUblRkXzE3NzEwNjEzMTQ6MTc3MTA2NDkxNF9WNA)

### 8.通过指针传递一个结构体给函数，函数修改结构体的内容。

解析：

```C
#include <stdio.h>

struct Person {
    char name[50];
    int age;
};

void updatePerson(struct Person *p) {
    p->age = 40;  // 修改结构体内容
}

int main() {
    struct Person person1 = {"John", 30};
    
    printf("Before update: Age = %d\n", person1.age);
    
    updatePerson(&person1);  // 传递结构体指针给函数

    printf("After update: Age = %d\n", person1.age);
    
    return 0;
}
```

![img](https://gcn59lcrd80x.feishu.cn/space/api/box/stream/download/asynccode/?code=OGY3MTIwYzdhZDlmYWE0MTQzNDEzYzU1MTZkM2VhMDRfR3lpZUFOZkpFMjNFdkI3ZDBDcFF1YkhUSkd0ZlJJam9fVG9rZW46VWhpMGJYaFJNb1RYd2J4MkJYZWMzdmVPbndiXzE3NzEwNjEzMTQ6MTc3MTA2NDkxNF9WNA)

### 9.定义两个整型变量a和b，并定义两个指针变量p1和p2分别指向a和b，通过指针变量输出a和b的值，通过指针变量求a和b的和。

解析：

```C
#include <stdio.h>

int main() {
    // 定义两个整型变量 a 和 b
    int a = 10, b = 20;
    
    // 定义两个指针变量 p1 和 p2
    int *p1 = &a;int *p2 = &b;
    
    // 通过指针变量输出 a 和 b 的值
    printf("Value of a: %d\n", *p1);  // 通过 p1 输出 a 的值
    printf("Value of b: %d\n", *p2);  // 通过 p2 输出 b 的值

    // 通过指针变量求 a 和 b 的和
    int sum = *p1 + *p2;
    printf("Sum of a and b: %d\n", sum);  // 输出 a 和 b 的和

    return 0;
}
```

![img](https://gcn59lcrd80x.feishu.cn/space/api/box/stream/download/asynccode/?code=YjJkODcxZmVmODMwN2YxMTNhMzk4MDIxMGNlNzJjN2FfZ0FTbGw1akd3UWlyZFNMRThJWnY1STR1NHRVRjFLcW1fVG9rZW46VzBhdmJWVjd1b2xTZDh4U2lPaGNabFdwbnFnXzE3NzEwNjEzMTQ6MTc3MTA2NDkxNF9WNA)

### 10.在主函数中定义整数变量a和b，在子函数中pchange(int *p1, int *p2)交换p1和p2的值，看看是否对a和b的值有影响。

解析：

```C
#include <stdio.h>

// 定义交换函数，接受两个指向整数的指针
void pchange(int *p1, int *p2) {// 交换指针 p1 和 p2 所指向的值
    int temp = *p1;
    *p1 = *p2;
    *p2 = temp;
}

int main() {
    // 在主函数中定义整数变量 a 和 b
    int a = 10, b = 20;
    
    // 输出交换前的值
    printf("Before change:\n");
    printf("a = %d, b = %d\n", a, b);
    
    // 调用 pchange 函数，传递 a 和 b 的地址
    pchange(&a, &b);
    
    // 输出交换后的值
    printf("\nAfter change:\n");
    printf("a = %d, b = %d\n", a, b);
    
    return 0;
}
```

![img](https://gcn59lcrd80x.feishu.cn/space/api/box/stream/download/asynccode/?code=MmRiNmViZWE4MzJjZGQ1NDFmNjNiMTFmNjRiZDg1M2VfNzRiRTI5T3VwSnVnQjVIZ2dNMTZrWFJzTWs4ZklNZk5fVG9rZW46RUE2WWJ4aHFwbzFHa254b2w5amNQekYybjVjXzE3NzEwNjEzMTQ6MTc3MTA2NDkxNF9WNA)