# 用函数实现程序模块化

## 函数的基本概念

### 什么是函数

函数是C语言中实现代码复用与程序模块化的核心机制，它是一段封装了特定功能的独立代码块。 本质上，函数可以看作是一个“输入→处理→输出”的黑盒：接收外部传入的参数，执行预设的逻辑，最后返回一个结果（或无返回值）。 函数的使用降低了代码冗余，避免重复编写相同逻辑；提升代码可读性与可维护性，将复杂问题拆解为多个小功能单元；便于多人协作开发，不同开发者可负责不同函数的实现。

### 第一个自定义函数

```C
// 示例：实现两个整数相加的函数
#include <stdio.h>

// 自定义加法函数
int add(int a, int b) {
    return a + b;
}

int main() {
    int x = 5, y = 3;
    // 调用自定义函数
    int result = add(x, y);
    printf("5 + 3 = %d\\n", result);
    return 0;
}
```

运行结果：

```C
5+3=8
```

代码解析：

定义了 add 函数，它接收两个 int 类型的参数，返回它们的和。 在 main 函数中调用 add，传入变量 x 和 y，得到返回值并打印。

### 函数的定义格式

完整语法结构：

```C
返回值类型 函数名(参数类型1 参数名1, 参数类型2 参数名2, ...) {
    // 函数体：实现功能的代码
    return 返回值;
}
```

- 返回值类型：函数执行后返回的数据类型，无返回值时用 void。
- 函数名：遵循标识符命名规则，见名知意。
- 参数列表：函数接收的输入，多个参数用逗号分隔；无参数时写 () 或 (void)。
- 函数体：包含实现功能的语句，return 用于返回结果（void 类型函数可省略 return）。

无参无返回值：

```C
void printHello() {
    printf("Hello, World!\\n");
}
```

无参无返回值：

```C
// 计算两数乘积
int multiply(int a, int b) {
    return a * b;
}
```

无参有返回值：

```C
// 功能：获取当前系统时间的秒数（模拟实现）
int getCurrentSecond() {
    return 42; // 示例返回值
}
```

有参有返回值：

```C++
// 功能：计算两数的乘积
int multiply(int a, int b) {
    return a * b;
}
```

## 函数的参数与返回值

### 无参函数与有参函数

无参函数：不依赖外部输入即可完成功能，通常用于执行固定逻辑（如打印信息、初始化操作）。

```C++
示例：printGreeting()
```

有参函数：需要外部传入参数才能动态执行逻辑，灵活性更高（如计算不同数值的和、判断不同数的奇偶性）。

```C++
示例：add(int a, int b)
```

### 形式参数与实际参数

形式参数（形参）：定义函数时声明的参数，仅在函数内部有效，是临时变量。 实际参数（实参）：调用函数时传入的具体值/变量，会将值传递给形参。

```C
// 形参：a, b
int add(int a, int b) {
    a = a + 1; // 修改形参，不会影响实参
    return a + b;
}

int main() {
    int x = 2, y = 3;
    // 实参：x, y
    int res = add(x, y);
    printf("res = %d, x = %d\n", res, x); // 输出 res = 6, x = 2
    return 0;
}
```

### 返回值的意义与应用

返回值是函数执行后的输出结果，通过 return 语句传递给调用者。 一个函数只能返回一个值，但可以通过指针或结构体实现“返回多个结果”。 例：判断一个数是否为偶数:

```C
#include <stdio.h>

// 定义函数：接收一个整数，返回一个整数
// 如果是偶数返回 1，否则返回 0
int is_even(int num) {
    if (num % 2 == 0) {
        return 1; // 通过 return 语句将 1 传回调用者
    } else {
        return 0; // 通过 return 语句将 0 传回调用者
    }
}

int main() {
    int number; 
    scanf("%d",&number);

    // 调用函数，并接收返回值
    int result = is_even(number);

    if (result == 1) {
        printf("%d 是偶数。\n", number);
    } else {
        printf("%d 是奇数。\n", number);
    }

    return 0;
}
```

![img](https://gcn59lcrd80x.feishu.cn/space/api/box/stream/download/asynccode/?code=NTYwNzExNWE1YjE5ODI3MDliMDc2NGIyMGFkMzY5ZWRfMzlITnFyMTljOUZxUlBDSEhEZ2NCSHF1Y1htSGVmZkhfVG9rZW46SHlyVGJRMkxnb0NqcTF4RTY3bGNJY2dEbm5oXzE3NzEwNjEzMjk6MTc3MTA2NDkyOV9WNA)

例：通过指针返回多个结果

```C
#include <stdio.h>

int divide_with_remainder(int a, int b, int *q, int *r) {
    // 安全检查：防止除以 0
    if (b == 0) {
        return 0; 
    }

    // *q 代表“找到 q 指向的那个内存盒子，把数据放进去”
    *q = a / b; 
    *r = a % b;

    return 1; // 返回 1 表示成功
}

int main() {
    int x;
    int y;

    scanf("%d",&x);
    scanf("%d",&y);

    // 1. 准备两个变量来接收结果
    // 此时它们里面是什么值并不重要，因为函数会覆盖它们
    int quotient_result;  
    int remainder_result;

    // 2. 调用函数
    // 注意：必须使用 & (取地址符) 将变量的地址传进去
    // 我们告诉函数：“把结果写到这两个变量的地址里去”
    int status = divide_with_remainder(x, y, &quotient_result, &remainder_result);

    // 3. 检查状态并输出
    if (status == 1) {
        printf("计算成功！\n");
        printf("%d 除以 %d ：商是 %d，余数是 %d\n", x, y, quotient_result, remainder_result);
    } else {
        printf("错误：除数不能为 0\n");
    }
    return 0;
}
```

![img](https://gcn59lcrd80x.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDAxMzdiYzU5YTFmN2ZmNzc5NTNlY2FhMjU2ZWZlYzRfb1BDNTl4MUFDeVFxWUZjOVFScGpFMVdqQUhneGtpeXZfVG9rZW46U0UyNGJRT1RubzR1SUd4eW1RZWNTcGJsbkd6XzE3NzEwNjEzMjk6MTc3MTA2NDkyOV9WNA)

![img](https://gcn59lcrd80x.feishu.cn/space/api/box/stream/download/asynccode/?code=MGFmMzliOTJmZjA5YzViNDQzOTY2NjI0Mzk0NDA1ZWJfdVhsT1BMRzlReVhQc1VQWnZPTEtmaW5tZlBZaG1jQ25fVG9rZW46TzRpSGJQYTZqb3hUVlJ4RkJWU2NEdHBnbjZkXzE3NzEwNjEzMjk6MTc3MTA2NDkyOV9WNA)

## 函数的声明与调用

### 函数声明

作用：告诉编译器函数的名称、返回值类型和参数列表，确保调用时类型匹配（避免“隐式声明”警告）。 语法：返回值类型 函数名(参数类型1, 参数类型2, ...);（参数名可省略，建议保留以提高可读性）。 场景：当函数定义在调用之后时，必须先声明再调用；也可将声明放在头文件中，实现跨文件调用。

```C++
// 函数声明（带参数名，更清晰）
int add(int a, int b);

int main() {
    int res = add(1, 2); // 先调用，后定义
    return 0;
}

// 函数定义
int add(int a, int b) {
    return a + b;
}
```

### 函数调用

语法：函数名(实参1, 实参2, ...); 执行流程： 1.程序暂停当前函数的执行，跳转到被调用函数的入口。 2.为被调用函数分配栈帧，存储形参、局部变量和返回地址。 3.执行被调用函数的代码，遇到 ?return? 时将结果返回，并释放栈帧。 4.回到原调用位置，继续执行后续代码。

## 递归函数

递归的概念： 函数在自身内部调用自身的编程方式，核心思想是“分解问题”：将复杂问题拆解为更小的、解法相同的子问题，直到子问题足够简单（终止条件）。 必须满足两个条件：

- 递归终止条件：明确的结束标志，防止无限递归。
- 递归递推关系：原问题可以表示为子问题的组合。

例：计算n的阶乘

```C
#include <stdio.h>

// long 类型是为了防止阶乘结果过大溢出
long factorial(int n) {
    // 当 n 降到 1 或 0 时，不再向下调用，直接返回 1
    if (n <= 1) {
        return 1;
    }

    // 原问题 factorial(n) 被拆解为：n * factorial(n - 1)
    return n * factorial(n - 1);
}

int main() {
    int number;
    scanf("%d",&number);
    // 调用函数
    long result = factorial(number);

    printf("%d 的阶乘是: %ld\n", number, result);

    return 0;
}
```

![img](https://gcn59lcrd80x.feishu.cn/space/api/box/stream/download/asynccode/?code=NzQ3Mzg3MjAwN2NiNGMxNzYyZmU5MDhmZTZmMTMwZTJfM0VQODJnV1FuZjNrWDR0SWQ4MmE1RVVoMUV0b00zcFJfVG9rZW46SEx6WmJkUlhzb2toQ1B4ejJSNGNiRTdQbjJkXzE3NzEwNjEzMjk6MTc3MTA2NDkyOV9WNA)

例：斐波那契数列

```C
#include <stdio.h>

int fibonacci(int n) {
    // 1. 终止条件 (Base Case)
    // 第 0 项是 0，第 1 项是 1
    if (n == 0) {
        return 0;
    }
    if (n == 1) {
        return 1;
    }

    // 2. 递推关系
    // 第 n 项 = 前一项 + 前两项
    return fibonacci(n - 1) + fibonacci(n - 2);
}

int main() {
    int n;
    printf("你想看斐波那契数列的第几项？(建议输入小于40的数): ");
    
    scanf("%d", &n);

    int result = fibonacci(n);
    printf("第 %d 项的结果是: %d\n", n, result);

    return 0;
}
```

![img](https://gcn59lcrd80x.feishu.cn/space/api/box/stream/download/asynccode/?code=NzA2MWMyNjhjNDQxMjVhMGVjN2U0YjdjOGIwYmE4YjRfVkNrbUN0WlFHUVpJckZzTVBUeW40Zm1MSWJUUndYbUxfVG9rZW46TnhZcWJ3anYxbzV6THV4VFduOGNCVmlTbmxmXzE3NzEwNjEzMjk6MTc3MTA2NDkyOV9WNA)

递归的优缺点： 优点：

代码简洁直观，适合处理具有自相似性的问题（如阶乘、斐波那契数列）。 缺点： 递归调用会频繁创建栈帧，占用更多内存，深度过大时可能导致栈溢出。 效率通常低于迭代，因为函数调用本身有开销。

### 函数调用的执行流程

\1. 栈帧的概念 每次函数调用时，系统会在栈内存上分配一块连续的内存空间，称为栈帧（Stack Frame）。 栈帧存储内容： 形参和局部变量。 返回地址（函数执行完毕后回到原调用位置的地址）。 栈帧指针（指向当前栈帧的起始地址）。 函数执行完毕后，栈帧会被自动释放，内存回收。  2. 执行流程示例

### 嵌套与链式调用

\1. 嵌套调用 指一个函数内部调用另一个函数，是实现复杂逻辑的常用方式。

```C++
// 功能：计算三个数的和
int addTwo(int a, int b) {
    return a + b;
}

int addThree(int x, int y, int z) {
    // 嵌套调用addTwo：先计算x+y，再与z相加
    return addTwo(addTwo(x, y), z);
}
```

\2. 链式调用 指将一个函数的返回值直接作为另一个函数的参数，使代码更简洁紧凑。

```C++
#include <stdio.h>
#include <string.h>

int main() {
    // 链式调用：strlen的返回值作为printf的参数
    printf("字符串\"Hello C\"的长度是：%d\\n", strlen("Hello C"));
    return 0;
}
```

运行结果：

```C++
字符串"Hello C"的长度是：7
```

## 综合运用

### 1.我们需要一个“闰年判断器”。请编写一个函数 `is_leap_year`。

解析：

```C++
#include <stdio.h>

// --- 自定义函数定义开始 ---

// 函数功能：判断是否为闰年
// 参数：year (待判断的年份)
// 返回值：1 表示是闰年，0 表示不是闰年
int is_leap_year(int year) {
    // 逻辑翻译：
    // (能被4整除 AND 不能被100整除) OR (能被400整除)
    if ((year % 4 == 0 && year % 100 != 0) || (year % 400 == 0)) {
        return 1; // 是闰年，返回真
    } else {
        return 0; // 不是闰年，返回假
    }
}

// --- 自定义函数定义结束 ---

int main() {
    int input_year;

    printf("请输入一个年份（例如 2024）: ");
    scanf("%d", &input_year);

    // 调用函数
    // 我们可以直接把函数调用放在 if 的条件里
    // 因为 is_leap_year(input_year) 会变成 1 或 0
    if (is_leap_year(input_year) == 1) {
        printf("%d 是闰年。\n", input_year);
    } else {
        printf("%d 不是闰年。\n", input_year);
    }

    return 0;
}
```

![img](https://gcn59lcrd80x.feishu.cn/space/api/box/stream/download/asynccode/?code=NTZhZjA4NDllYzllMjdhMGRiYjAzZDU0NWI0MGNhNTFfeUtxZ0tqWFdRdWRuS1p4VEtJb1JnUjZYbEhEcDhJNFhfVG9rZW46U3I4SGJWZjI4b0FsUVh4ZE9pcGNVRHFMbmdnXzE3NzEwNjEzMjk6MTc3MTA2NDkyOV9WNA)

### 2.请分析以下代码，回答两个问题：

```C
void magic_change(int n) {
    n = 888; // 试图修改 n
    printf("函数内部 n 的值: %d\n", n);
}

int main() {
    int n = 10;
    magic_change(n);
    printf("主函数中 n 的值: %d\n", n);
    return 0;
}
```

**预测输出**：程序的最后一行输出是什么？

**原理分析**：为什么在 `magic_change` 函数里修改了 `n`，`main` 函数里的 `n` 却没有变？请用“内存”**或**“复印件”的概念来解释“形参”和“实参”的关系。

解析：

程序的最后一行输出是： **`主函数中 n 的值: 10`**

在计算机内存中，这两个 `n` 虽然名字一样，但它们根本就是**两个完全不同的变量**，住在完全不同的“房间”（内存地址）里。

1. **不同的房间**：
	1. `main` 函数里的 `n` 住在一个内存地址（比如 `0x100`）。
	2. `magic_change` 函数里的 `n` 住在另一个内存地址（比如 `0x200`）。
2. **单向传递**：
	1. 调用函数时，系统只是把 `0x100` 里的数值（10）**复制**了一份，填到了 `0x200` 里。这就是所谓的**“值传递” (Pass by Value)**。
3. **互不干扰**：
	1. `magic_change` 执行 `n = 888` 时，它修改的是 **`0x200`** 里的数据。
	2. **`0x100`** 里的数据从未被触碰，所以主函数的 `n` 保持不变。

### 3.下面的代码在很多编译器中会报错或报警告（Implicit declaration...），导致无法运行。

**指出错误原因**：为什么 `main` 函数找不到 `get_sum`？

**提供两种修改方案**：

- 方案 A：不移动函数代码的位置。
- 方案 B：移动函数代码的位置

```C
#include <stdio.h>

int main() {
    int res = get_sum(10, 20); // 报错行
    printf("结果是: %d", res);
    return 0;
}

int get_sum(int a, int b) {
    return a + b;
}
```

解析：

**错误原因分析**

**为什么 main 函数找不到 get_sum？**

- **原因：** C 语言编译器在编译代码时，是从上往下、一行一行读取的（Sequential Processing）。
- **过程：** 当编译器读到 `main` 函数里的第 4 行 `get_sum(10, 20)` 时，它往上看，发现之前从来没有出现过 `get_sum` 这个名字。
- **后果：** 编译器会困惑：“这是个啥？我没见过啊。”
	- 在老标准（C90）中，它会猜测这是一个返回 int 的函数（隐式声明），但这很危险。
	- 在新标准（C99及以后）或严格模式下，编译器直接报错：**“Implicit declaration of function 'get_sum' is invalid”**（函数 'get_sum' 的隐式声明无效）。

**解决方案：**

**方案 A：不移动代码位置（使用函数声明）**

**核心思路：** 在 `main` 函数之前，先写一句“预告”，告诉编译器：“后面会有个叫 `get_sum` 的函数，长这个样子，请放心通过。”这行代码叫做 **函数原型 (Function Prototype)** 或 **函数声明**。

```C++
#include <stdio.h>

// 【方案 A 修改处】在这里加一行声明（注意分号不能少）
int get_sum(int a, int b); 

int main() {
    int res = get_sum(10, 20); // 此时编译器已经知道 get_sum 是什么了
    printf("结果是: %d", res);
    return 0;
}

// 函数的定义依然在下面
int get_sum(int a, int b) {
    return a + b;
}
```

**方案 B：移动代码位置（先定义后使用）**

**核心思路：** 将 `get_sum` 函数的整个身体剪切，粘贴到 `main` 函数的上面。这样编译器读到 `main` 时，已经认识 `get_sum` 了。

```C++
#include <stdio.h>

// 【方案 B 修改处】把定义搬到 main 前面
int get_sum(int a, int b) {
    return a + b;
}

int main() {
    int res = get_sum(10, 20); // 编译器：哦，这个函数刚才我见过了
    printf("结果是: %d", res);
    return 0;
}
```

### 4.不使用数组，只使用简单的 `int` 变量和函数，找出 **4 个整数中的最大值**。 请按以下步骤编写代码：

1. 编写一个函数 `max2(int a, int b)`，返回两个数中的较大值。
2. 编写一个函数 `max4(int a, int b, int c, int d)`。
	1. **要求**：`max4` 函数内部**不能**使用 `if` 语句比较大小，必须通过**调用 3 次** **`max2`** **函数**来得到结果。
3. 在 `main` 函数中测试它。

```C
#include <stdio.h>

// --- 1. 定义 helper 函数：比较两数最大值 ---
int max2(int a, int b) {
    // 基础逻辑：谁大返回谁
    if (a > b) {
        return a;
    } else {
        return b;
    }
}

// --- 2. 定义核心函数：比较四数最大值 ---
int max4(int a, int b, int c, int d) {
    // 核心思想：锦标赛淘汰制
    // 第一轮：找出 a 和 b 的胜者
    int max_ab = max2(a, b); 
    
    // 第二轮：找出 c 和 d 的胜者
    int max_cd = max2(c, d); 
    
    // 决赛：找出两个胜者中的总冠军
    return max2(max_ab, max_cd);
    
    // 也可以写成一行（链式调用）：
    // return max2(max2(a, b), max2(c, d));
}

int main() {
    int n1, n2, n3, n4;
    
    printf("请输入4个整数（用空格隔开）: ");
    scanf("%d %d %d %d", &n1, &n2, &n3, &n4);

    int result = max4(n1, n2, n3, n4);
    
    printf("这四个数中最大的是: %d\n", result);

    return 0;
}
```

![img](https://gcn59lcrd80x.feishu.cn/space/api/box/stream/download/asynccode/?code=Y2Q2NWVhNTU5NWMwZjllNDZkZTNiYTYyNzAyNDQ3NGJfbXNRMWRBbzd6c1ZXR09FWkRWaU9mMnJOSjJ3QnhiaFJfVG9rZW46VmtzTmJTT0syb0hjRkx4dWNueWNLVHIwbjdiXzE3NzEwNjEzMjk6MTc3MTA2NDkyOV9WNA)

### 5.递归最难的不是写，而是**读**。请人肉模拟计算机，写出下面这段代码的**完整输出结果**。

```C
#include <stdio.h>

void move(int n) {
    if (n < 1) return; // 终止条件
    
    printf("进: %d\n", n); // 递（去的过程）
    
    move(n - 2); // 递归调用自身
    
    printf("出: %d\n", n); // 归（回来的过程）
}

int main() {
    move(5);
    return 0;
}
```

![img](https://gcn59lcrd80x.feishu.cn/space/api/box/stream/download/asynccode/?code=N2QyMzI1MjZmZWRhMTA3MjUyOTJlZWE0MTBjMGE3MzJfT1hzaXI0aXhPazlEYzBucVhHQzhxT1FYbWNxWUpKWHNfVG9rZW46Q3dDbGJCcjV6b3ljeFd4ZFlvSmNnOTZKbjRmXzE3NzEwNjEzMjk6MTc3MTA2NDkyOV9WNA)

只要没碰到终止条件，程序就一直往里钻，暂停手中的工作，去处理下一层。

1. **调用** **`move(5)`**：
	1. 判断 `5 < 1`？否。
	2. 执行打印：**`进: 5`**
	3. 遇到 `move(5-2)` 即 `move(3)`：**暂停** `move(5)` 的剩余工作（还没执行到“出”），立刻进入 `move(3)`。
2. **进入** **`move(3)`**：
	1. 判断 `3 < 1`？否。
	2. 执行打印：**`进: 3`**
	3. 遇到 `move(3-2)` 即 `move(1)`：**暂停** `move(3)` 的剩余工作，立刻进入 `move(1)`。
3. **进入** **`move(1)`**：
	1. 判断 `1 < 1`？否。
	2. 执行打印：**`进: 1`**
	3. 遇到 `move(1-2)` 即 `move(-1)`：**暂停** `move(1)` 的剩余工作，立刻进入 `move(-1)`。

**第二阶段：触底反弹 (Base Case)**

1. **进入** **`move(-1)`**：
	1. 判断 `-1 < 1`？**是！**
	2. **触发** **`return`**：这个函数直接结束，什么都不打印，直接返回到上一层（调用它的地方）。

**第三阶段：“归”——向上回溯 (Coming Back)**

> 刚才暂停的工作，现在要继续做完。这是新手最容易漏掉的部分。

1. **回到** **`move(1)`**：
	1. 刚才卡在 `move(-1)` 那行，现在那行执行完了。
	2. 继续执行下一行：打印 **`出: 1`**
	3. 函数结束，返回到上一层。
2. **回到** **`move(3)`**：
	1. 刚才卡在 `move(1)` 那行，现在那行执行完了。
	2. 继续执行下一行：打印 **`出: 3`**
	3. 函数结束，返回到上一层。
3. **回到** **`move(5)`**：
	1. 刚才卡在 `move(3)` 那行，现在那行执行完了。
	2. 继续执行下一行：打印 **`出: 5`**
	3. 函数结束，彻底退出。

### 6.编写一个函数 `add(int a, int b)`，接收两个整数，计算它们的和并通过 `return` 返回。在 `main` 函数中输入两个数，调用该函数并输出结果。

解析：

```C++
#include <stdio.h>

int add(int a, int b) {
    // 计算和，并通过 return 语句将结果“扔”回给调用者
    return a + b;
}

int main() {
    int x, y;
    int sum; // 用于存储计算结果

    // 1. 输入阶段
    printf("请输入两个整数（中间用空格隔开）: ");
    scanf("%d %d", &x, &y);

    // 2. 调用函数阶段
    // add(x, y) 会执行跳转，把 x 和 y 的值传给 a 和 b
    // 函数执行完毕后，整句表达式变成计算结果，赋值给 sum
    sum = add(x, y);

    // 3. 输出阶段
    printf("计算结果: %d + %d = %d\n", x, y, sum);

    return 0;
}
```

![img](https://gcn59lcrd80x.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDdjOTBmNjgyZTM4MWJjODUwMDIxNjk1M2QyMzc2ZjdfckQyc3JUZGQxbUZ2OHd4QzVEd2M1UnhlMG56ejNoVWlfVG9rZW46VFRDRmI1RDF1b0FnaHp4clVqSGN1amdNbldiXzE3NzEwNjEzMjk6MTc3MTA2NDkyOV9WNA)

### 7.编写一个函数 `sum_n(int n)`，计算从 1 加到 n 的总和（即 1+2+...+n）并返回结果。

```C++
#include <stdio.h>

int sum_n(int n) {
    int sum = 0; // 1. 初始化累加器 (非常重要！必须设为0)
    
    // 2. 循环累加
    // 让 i 从 1 变到 n，每次加进 sum 里
    for (int i = 1; i <= n; i++) {
        sum = sum + i; // 也可以写成 sum += i;
    }
    
    // 3. 返回最终结果
    return sum;
}

int main() {
    int number;
    printf("请输入一个整数 n: ");
    scanf("%d", &number);

    // 调用函数
    int result = sum_n(number);

    printf("从 1 加到 %d 的总和是: %d\n", number, result);

    return 0;
}
```

![img](https://gcn59lcrd80x.feishu.cn/space/api/box/stream/download/asynccode/?code=NTU4ZWFkNDMxYWJlNzNiMTFiYmE5NzEzMDc1ZjljZTlfQ0psYjZVQTVNUTNQREV5NnkweEFjSmZvVWpoTXd4ckJfVG9rZW46SzFBeGJTZXhQb3VUd0Z4Y3pEMGNoYmVqbkxkXzE3NzEwNjEzMjk6MTc3MTA2NDkyOV9WNA)

### 8.编写一个函数 `mid3(int a, int b, int c)`。它的功能是返回这三个数中**数值处于中间**的那个数（例如输入 10, 30, 20，返回 20）。

```C
#include <stdio.h>

int mid3(int a, int b, int c) {
    // 1. 判断 a 是否是中间数
    // 情况一：b <= a <= c
    // 情况二：c <= a <= b
    if ((a >= b && a <= c) || (a >= c && a <= b)) {
        return a;
    }
    
    // 2. 判断 b 是否是中间数
    // 情况一：a <= b <= c
    // 情况二：c <= b <= a
    if ((b >= a && b <= c) || (b >= c && b <= a)) {
        return b;
    }

    // 3. 如果 a 和 b 都不是，那中间数一定是 c
    return c;
}

int main() {
    int n1, n2, n3;
    printf("请输入三个整数（例如 10 30 20）: ");
    scanf("%d %d %d", &n1, &n2, &n3);

    int result = mid3(n1, n2, n3);
    printf("中间数是: %d\n", result);

    return 0;
}
```

![img](https://gcn59lcrd80x.feishu.cn/space/api/box/stream/download/asynccode/?code=ZGJjMzJjMmE1YmMwYzRkY2EzNjljMjlmMzQ1MTBhNzJfWTh4MHpSRkUwUzZCQjhBbm1ZeHpCNkYwdVMyb0lvWElfVG9rZW46Rk1UaWJuV212b2d5S1F4WG9UdWNMQU5QblZiXzE3NzEwNjEzMjk6MTc3MTA2NDkyOV9WNA)

在代码中，**绝对不能写** `if (b <= a <= c)`。因为计算机是从左到右执行的：

1. 先算 `b <= a`，得到结果 1 或 0。
2. 再拿这个 1 或 0 去和 `c` 比较（`1 <= c`），这完全偏离了原本的数学含义。

必须使用 `&&`（逻辑与）将两个条件连接起来。

逻辑覆盖

为什么要判断 `(a >= b && a <= c)` **或者** `(a >= c && a <= b)`？

因为我们不知道 $$$$ 和 $$$$ 谁大谁小。

- 如果是 `10, 20, 30`，那么 $a(20)$ 夹在 $b(10)$ 和 $c(30)$ 之间。
- 如果是 `30, 20, 10`，那么 $a(20)$ 夹在 $c(10)$ 和 $b(30)$ 之间。
- 这两种情况，$a$ 都是中间数。

### 9.编写一个函数 `digit_sum(int n)`，计算一个整数所有数位之和。例如输入 `1234`，计算 `1+2+3+4`，返回 `10`。（提示：使用 `%` 和 `/` 循环处理）。

```C++
#include <stdio.h>

int digit_sum(int n) {
    int sum = 0; // 初始化累加器
    
    // 如果输入是负数，先转为正数（可选，视题目要求而定）
    if (n < 0) {
        n = -n;
    }

    // 循环条件：只要 n 还没被“剥”完（大于 0），就继续做
    while (n > 0) {
        // 1. 取出最后一位数字 (使用取模运算符 %)
        int last_digit = n % 10;
        
        // 2. 加到总和里
        sum = sum + last_digit;
        
        // 3. 删掉最后一位数字 (使用整除运算符 /)
        n = n / 10;
    }

    return sum;
}

int main() {
    int number;
    printf("请输入一个整数（例如 1234）: ");
    scanf("%d", &number);

    int result = digit_sum(number);
    printf("数字 %d 的各位之和是: %d\n", number, result);

    return 0;
}
```

![img](https://gcn59lcrd80x.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjM3ZTk5OTQ2ZDVjMjA5NGFiODk0YThjMDgzMTU1OWFfbjFQM2JYSUgxZHRWRGF0VlJpVFd0SGZYWjlzT0Y2bHVfVG9rZW46RzBpZGJJVDJZb3VOM1p4V09QMWN4Q3MybnR4XzE3NzEwNjEzMjk6MTc3MTA2NDkyOV9WNA)

### 10.请写出下面代码完整的打印结果，并解释为什么是这个顺序。

```C
void recursion_test(int n) {
    if (n < 1) return;
    printf("Level %d Down\n", n); // 去的过程
    recursion_test(n - 1);        // 递归调用
    printf("Level %d Up\n", n);   // 回的过程
}
int main() {
    recursion_test(3);
    return 0;
}
```

解析：

![img](https://gcn59lcrd80x.feishu.cn/space/api/box/stream/download/asynccode/?code=OWIzNzJjMDdjN2U2NjFkZTViNWEwZGYwYzcxODc0OGZfT1VTWHhhQk5vQ3pFcEt1VDZ2NmRIcERqMzJ5ZnFuS3NfVG9rZW46WjJIeWJyemNtb3ZlZnZ4YTJpRWM1c2s3bjJkXzE3NzEwNjEzMjk6MTc3MTA2NDkyOV9WNA)

**第一阶段：“递” (Going Down) —— 压栈**

程序像剥洋葱一样，一层层往里进，**但在每一层都还没来得及做完所有事情**（只做了上半部分，下半部分被暂停了）。

1. **调用** **`recursion_test(3)`**：
	1. 打印 `Level 3 Down`
	2. 遇到 `recursion_test(2)`，**暂停**当前工作，进入下一层。
2. **调用** **`recursion_test(2)`**：
	1. 打印 `Level 2 Down`
	2. 遇到 `recursion_test(1)`，**暂停**当前工作，进入下一层。
3. **调用** **`recursion_test(1)`**：
	1. 打印 `Level 1 Down`
	2. 遇到 `recursion_test(0)`，**暂停**当前工作，进入下一层。

**第二阶段：触底 (Base Case)**

1. **调用** **`recursion_test(0)`**：
	1. `n < 1` 成立。
	2. 执行 `return`，**直接结束**这一层，不打印任何东西。

**第三阶段：“归” (Coming Up) —— 弹栈**

这是最关键的一步！程序开始从最里面那层往外退，**继续执行刚才暂停的代码（即下半部分）**。

1. **回到** **`recursion_test(1)`**：
	1. 刚才卡在调用 `0` 那行，现在调用结束了。
	2. 继续执行下一行：打印 `Level 1 Up`
	3. 函数结束，销毁，返回上一层。
2. **回到** **`recursion_test(2)`**：
	1. 刚才卡在调用 `1` 那行，现在调用结束了。
	2. 继续执行下一行：打印 `Level 2 Up`
	3. 函数结束，销毁，返回上一层。
3. **回到** **`recursion_test(3)`**：
	1. 刚才卡在调用 `2` 那行，现在调用结束了。
	2. 继续执行下一行：打印 `Level 3 Up`
	3. 函数彻底结束。