# 数组与结构体

在前面的学习中，我们已经学习了循环结构，其核心作用是重复执行相同逻辑，处理有规律的单个数据。现在我们要用循环依次输入三个学生的成绩，并计算它们的平均成绩：

```C++
// 循环处理单个数据的例子，先写在黑板上
int score1, score2, score3, sum = 0;
for(int i=1; i<=3; i++){
    if(i==1) scanf("%d", &score1);
    if(i==2) scanf("%d", &score2);
    if(i==3) scanf("%d", &score3);
}
sum = score1 + score2 + score3;
printf("平均分：%d", sum/3);
```

但显而易见的是，如果我们要输入更多人的成绩时，使用循环逐个数据处理会使得变量冗余，代码大量重复，此时，我们要引入一个新的概念`数组`，并且使得数组中的数据通过数组名和下标来唯一确定，来提高运行效率。

## 1.数组

### 1.1数组基础

#### 1.1.1数组的定义

数组是相同数据类型的元素按连续内存地址有序存储的集合。这里需要强调**相同数据类型的**数据，不能把不同类型的数据输入到一起(例如把学生的成绩和学生姓名输入到同一个数组中)。

#### 1.1.2数组的核心特性

- 定长性：静态数组定义时必须指定元素总个数，长度一旦确定，运行时不可动态修改；

```C++
int arr[5] = {1,2,3,4,5};
```

- 同类型性：数组内所有元素必须是同一数据类型，不允许混合存储int、char、double或自定义结构体等不同类型数据；

```C++
int int_arr[] = {1,2,3}; 
```

- 连续内存性：所有元素在内存中连续排布，无间隙，相邻元素的地址差等于单个元素的字节数（由数据类型决定）；

```C++
#include <stdio.h>

int main() {
    int arr[] = {10, 20, 30, 40, 50};
    // 计算相邻元素的地址差（单位为int）
    printf("相邻元素地址差（int单位）：%ld\n", &arr[1] - &arr[0]);
    // 计算相邻元素的地址差（单位为字节）
    printf("相邻元素地址差（字节）：%ld\n", (long)&arr[1] - (long)&arr[0]);
    return 0;
}
```

- 随机访问性：通过下标可直接访问任意元素，无需遍历前置元素。

```C++
#include <stdio.h>

int main() {
    int arr[] = {10, 20, 30, 40, 50};
    // 直接通过下标访问第4个元素（下标3），无需遍历前面元素
    printf("直接访问下标3的元素：%d\\n", arr[3]);
    return 0;
}
```

#### 1.1.3数组的声明语法

语法格式：

```C++
数据类型 数组名【常量长度】
```

注意:

- 数组名的命名规则和变量名相同，遵循标识符命名规则。
- 在定义数组时，需要指定数组中元素的个数，方括号中的常量表达式即为数组中元素的个数，但需要尤为注意的是，**计算机中定义的数组下标从0开始**，即定义整型数组`int` a[10]，则计算机进行存储时按照a[0],a[1],a[2],a[3],....a[9]共10个数字的顺序进行存储，**不存在a[10]**
- 方括号中的常量表达式可以包含常量和符号常量，例如`int` a[3+5]是合法的，因为可以确定数组中数据的个数，但是不允许运用变量定义数组，例如`int` a[n]是不合法的，即C语言不允许对数组的大小进行动态定义，这些细节需要读者稍加注意。

#### 1.1.4数组的初始化

- 零值初始化：所有元素统一初始化为0（数值型）或 '\0' （字符型），语法为 {} 或 {0} ；

```C++
int arr[5] = {}; 
```

- 静态初始化：显式指定部分或全部元素的值，未指定的元素自动补0（数值型）或'\0'（字符型）；

```C++
int arr[5] = {1, 2};
```

- 统一初始化：可省略等号=，直接用{}初始化，语法更简洁；

```C++
 int arr[5]{1, 2, 3};
```

#### 1.1.5数组中元素的访问

- 下标访问法

语法格式：

```C++
数组名[下标]
```

数组名：数组名的本质是一个指向数组首元素的常量指针，它的值不能被修改。 下标：一个整数表达式，代表元素在数组中的位置索引。**数组下标从0开始，而非1**。 例如：arr[0]是第1个元素，arr[1]是第2个元素，依此类推。 对于长度为n的数组，下标必须满足：0 ≤ 下标 ≤ n-1 若下标超出合法范围，会触发未定义行为（程序崩溃、输出乱码或数据被篡改），且编译器不会报错。

```C++
int arr[5] = {1,2,3,4,5};
arr[5] = 6; // 非法！下标5越界（合法范围0~4）
```

直接给数组名[下标]赋值，即可修改对应位置的元素。

```C++
#include <stdio.h>
int main() {
    int arr[] = {10,20,30,40,50};
    printf("第3个元素的值是：%d\\n", arr[2]); // 输出30
    return 0;
}
```

直接使用数组名[下标]来获取对应位置的元素值，可用于输出或参与计算。

```C++
#include <stdio.h>
int main() {
    int arr[] = {10,20,30,40,50};
    arr[2] = 35; // 将第3个元素从30修改为35
    printf("修改后第3个元素的值是：%d\\n", arr[2]); // 输出35
    return 0;
}
```

 除此之外，C语言中还可以使用**指针访问法**对数组中的元素进行访问，但由于本书排版，指针尚未进行学习，由此编者将在指针章节后续对数组中关于指针的知识进行讲解。本部分内容详情见第六章第2.1节。

#### 1.1.6数组的遍历

为了能安全、完整地遍历数组。我们通常先用`sizeof`算出数组长度，再用这个值来控制循环，避免下标越界。

```C++
int len = sizeof(数组名) / sizeof(数组名[0]);
```

sizeof(数组名) ：获取整个数组在内存中占用的总字节数。 sizeof(数组名[0]) ：获取数组中单个元素占用的字节数。 两者相除，得到数组的元素总个数。

例:

```C++
#include <stdio.h>

int main() {
    // 定义一个int类型数组
    int scores[] = {90, 85, 95, 88, 92, 78};
    
    // 计算数组长度
    int len = sizeof(scores) / sizeof(scores[0]);
    
    // 输出结果
    printf("数组总字节数：%zu\\n", sizeof(scores));
    printf("单个元素字节数：%zu\\n", sizeof(scores[0]));
    printf("数组的元素个数（长度）：%d\\n", len);

    // 利用长度遍历数组
    printf("数组元素：");
    for (int i = 0; i < len; i++) {
        printf("%d ", scores[i]);
    }
    printf("\\n");

    return 0;
}
```

输出结果：

```C++
数组总字节数：24
单个元素字节数：4
数组的元素个数（长度）：6
数组元素：90 85 95 88 92 78 
```

在这个例子中，`int`类型占4字节，数组总字节数24除以单个元素字节数4，得到长度为6。

- for循环下标法

语法格式：

```C++
// 1. 计算长度
int len = sizeof(arr)/sizeof(arr[0]);
// 2. for循环遍历：初始化 | 条件判断 | 更新迭代 三要素合一
for (int i = 0; i < len; i++) {
    // 对arr[i]的读/写操作
}
```

i作为数组下标，必须从0初始化，循环条件为i < len（若写i <= len会下标越界，触发未定义行为）。

例：输出int数组所有元素。

```C++
#include <stdio.h>
int main()
{
    int arr[5] = {1, 2, 3, 4, 5};        //定义数组
    int len =sizeof(arr)/sizeof(arr[0]); //求数组长度  
    int i;
    
    for(i = 0; i < len; i++) {            //用for循环输出各值
        printf("arr[%d]=%d\n", i, arr[i]);
    }
    
    return 0;
}
```

运行结果:

```C++
arr[0]=1
arr[1]=2
arr[2]=3
arr[3]=4
arr[4]=5
```

例：求int数组所有元素的和与平均值。

```C++
#include <stdio.h>
int main()
{
    int sum = 0, i = 0;                     //定义和
    float s = 0;                            //定义平均值
    int arr[5] = {1, 2, 3, 4, 5};
    int len = sizeof(arr)/sizeof(arr[0]);   //计算长度
    
    for(i = 0; i < len; i++) {
        sum = sum + arr[i];                  //循环求和
        }
    s = sum / len;    
    printf("数组所有元素的和为%d\n平均值为%.2f", sum , s);   
     
    return 0;
 }
```

运行结果:

```C++
数组所有元素的和为15
平均值为3.00
```

- while循环法

语法格式：

```C++
// 1. 计算长度
int len = sizeof(arr)/sizeof(arr[0]);
// 2. 初始化计数器（必须写在while外，否则每次循环重置为0）
int i = 0;
// 3. while循环：仅写条件判断
while (i < len) {
    // 对arr[i]的读/写操作
    i++; // 计数器自增（必须写在循环内，否则无限循环！）
}
```

如果遗漏循环内的i++，导致计数器始终为0，会触发无限循环；也可能因提前修改i导致越界。

i定义在while外，可根据条件在循环内灵活调整步长（如i+=2）。

例：输出int数组所有元素。

```C++
#include <stdio.h>
int main()
{
    int arr[5] = {1, 2, 3, 4, 5};        
    int len =sizeof(arr)/sizeof(arr[0]); //1.求数组长度  
    int i = 0;                           //2.初始化计数器
        
    while(i < len) {                        
        printf("arr[%d]=%d\n", i, arr[i]);
        i++;                                
    }
    
    return 0;
}
```

运行结果:

```C++
arr[0]=1
arr[1]=2
arr[2]=3
arr[3]=4
arr[4]=5
```

- for循环指针法

### 1.2一维数组

一维数组的内容与数组基础内容大致相同，在前面我们已经学习了一部分，在这里简单回顾一下。

一维数组和数组基础内容有很大一部是重复的，排版时可以重新调整一下，合并删减。

#### 1.2.1一维数组的声明

语法格式：

```C++
数据类型 数组名[长度];        //长度决定数组可存储的元素个数。
```

#### 1.2.2一维数组的初始化

完整初始化(即给数组内各个数据都进行赋值)：

```C++
//数据类型 数组名[长度] = {元素1, 元素2, ...};
int arr1[5] = {1, 2, 3, 4, 5};        //元素个数不可超过数组长度。
```

省略长度初始化：

```C++
//数据类型 数组名[] = {元素1, 元素2, ...};
int arr2[] = {1, 2, 3};                   //编译器自动根据元素个数推导数组长度为3
```

部分初始化：

```C++
//未赋值的元素自动初始化为0
int arr[5] = {1,2};                      //剩余3个元素为0        
```

空初始化：

```C++
//数据类型 数组名[长度] = {};
int arr4[5] = {0};               //所有元素统一初始化为0
```

#### 1.2.3一维数组的遍历

- for循环下标法

```C++
#include <stdio.h>

int main() {
    // 定义并初始化一个int数组
    int arr[] = {10, 20, 30, 40, 50};
    // 计算数组长度：总字节数 ÷ 单个元素字节数
    int len = sizeof(arr) / sizeof(arr[0]);
    
    // 输出标题
    printf("for循环下标法遍历：");
    // for循环三要素：初始化i=0、条件i<len、每次循环i自增1
    // i作为数组下标，从0开始到len-1结束，确保不越界
    for (int i = 0; i < len; i++) {
        // 通过下标arr[i]访问元素并输出
        printf("%d ", arr[i]);
    }
    printf("\\n");

    return 0;
}#include <stdio.h>

int main() {
    // 定义并初始化一个int数组
    int arr[] = {10, 20, 30, 40, 50};
    // 计算数组长度：总字节数 ÷ 单个元素字节数
    int len = sizeof(arr) / sizeof(arr[0]);
    
    // 输出标题
    printf("for循环下标法遍历：");
    // for循环三要素：初始化i=0、条件i<len、每次循环i自增1
    // i作为数组下标，从0开始到len-1结束，确保不越界
    for (int i = 0; i < len; i++) {
        // 通过下标arr[i]访问元素并输出
        printf("%d ", arr[i]);
    }
    printf("\\n");

    return 0;
}
```

**（↑上面这个代码是不是重复了**）

运行结果：

```C++
for循环下标法遍历：10 20 30 40 50 
```

- while循环法

```C++
#include <stdio.h>

int main() {
    // 定义并初始化一个int数组
    int arr[] = {10, 20, 30, 40, 50};
    // 计算数组长度
    int len = sizeof(arr) / sizeof(arr[0]);
    
    // 输出标题
    printf("while循环下标法遍历：");
    // 1. 初始化计数器i（必须在while循环外定义）
    int i = 0;
    // 2. while循环仅做条件判断：i小于数组长度时继续循环
    while (i < len) {
        // 通过下标arr[i]访问元素并输出
        printf("%d ", arr[i]);
        // 3. 计数器自增（必须写在循环内，否则会无限循环！）
        i++;
    }
    printf("\n");

    return 0;
}
```

运行结果：

```C++
while循环下标法遍历：10 20 30 40 50 
```

#### 1.2.4特殊的一维数组（字符数组）

字符数组的本质是存储`char`类型数据的一维数组，与普通数组的唯一区别在于它通常以\0（ASCII值为0的空字符）作为结束标志，用来标识一个字符串的结束。

定义一个长度为10的字符数组（未初始化），这个数组可以存储最多9个可见字符，最后一个位置必须留给结束符 \0 。

注意：C语言中没有字符串类型，也没有字符串变量，字符串是存放在字符型数组中的

##### 1.2.4.1定义及初始化

首先是字符数组的定义：

  定义字符数组的方法与定义数值型数组的方法类似，例如：

```C
char c[10];
c[0]='I';C[1]='';C[2]='a';C[3]='m';C[4]='';C[5]='h';
c[6]='a';c[7]='p';c[8]='p';c[9]='y';
```

   以上定义了c为字符数组，包含10个元素。同时由于字符型数据是以ASCII代码形式存放，因此也可以用整型数组来存放字符数据，不过这种方式在虽然合法，但浪费存储空间。

  对于字符数组有几种常见的初始化方式，不同方式的**核心区别在于是否自动添加\0。**

- 字符串直接初始化  这是最常用的初始化方式。编译器会自动在字符串末尾添加?'\\0'?，无需手动输入。数组长度由编译器自动推导，等于字符串长度+1。

```C++
char str[] = "hello";
```

- 大括号初始化（需手动加\0） 如果不手动添加\0，这个字符数组只是一个普通的字符集合，无法被printf("%s")或strlen等字符串函数正确识别。

```C++
// 错误：没有'\\0'，无法作为字符串使用
char str1[] = {'h', 'e', 'l', 'l', 'o'};
// 正确：手动添加结束符
char str2[] = {'h', 'e', 'l', 'l', 'o', '\\0'};
```

- 空初始化（所有元素置0） 这种方式适合后续动态输入字符串的场景，保证数组一开始就有有效的结束符。

```C++
char str[10] = {0};
```

要注意`scanf("%s")`无法读取带空格的字符串，它会在遇到第一个空格时停止。 C语言标准库提供了一系列函数来操作字符串，如`strlen`（获取长度）、strcpy（拷贝）、`strcat`（拼接）、`strcmp`（比较）等，需包含头文件`<string.h>`

##### 1.2.4.2字符数组的遍历 字符数组的遍历有两种方式：按数组长度遍历和按\0结束符遍历。

- 按数组长度遍历（与普通数组一样） 和遍历普通`int`数组的方式完全一致，通过计算数组总长度来控制循环。

```C++
#include <stdio.h>

int main() {
    char str[] = "hello";
    int len = sizeof(str) / sizeof(str[0]);
    // 计算数组长度：总字节数 ÷ 单个元素字节数
    for (int i = 0; i < len; i++) {
        printf("%c ", str[i]);
    }
    // 输出：h e l l o
    return 0;
}
```

- 按\0结束符遍历（更常用） 这种方式是处理字符串的标准做法，它不依赖于数组的总长度，只关心有效字符。只要遇到\0就停止，避免了遍历到数组中无效的部分。

```C++
#include <stdio.h>

int main() {
    char str[] = "hello";
    int i = 0;
    printf("字符数组遍历：");
    while (str[i] != '\\0') {
        printf("%c ", str[i]);
        i++;
    }
    // 输出：h e l l o
    return 0;
}
```

#### 1.2.5一维数组的运用

最值，求和，冒泡，二分法，数组的逆序......

##### 1.2.5.1求最值

例.有以下数组` arr[5]= {22, 33, 55, 44, 11}`

使用代码完成:

- 求最大值和最小值

```C++
#include <stdio.h>
int main()
{
    int arr[5] = {22, 33, 55, 44, 11};
    int len = sizeof(arr)/sizeof(arr[0]);
    int max = arr[0] , min = arr[0];    //1.定义最大值和最小值
    int i;
    
    for(i = 0; i < len; i++) {      //2.比较相邻的两个数
        if(max < arr[i]) {
            max = arr[i];
        }
        if(min > arr[i]) {
            min = arr[i];
        }
    }
        printf("该数组的最大值为%d\n最小值为%d", max, min);    
        //3.输出最终结果
  
    return 0;  
}  
```

解析：先**假设最大值和最小值都是第一个元素**，比较最大值与最小值与各元素的相对大小，将比前一个最大值大的元素赋给最大值(max),将比前一个最小值小的元素赋给最小值(min)，那么循环结束后的max与min就是数组的最大值与最小值

运行结果:

```C++
该数组的最大值为55
最小值为11
```

##### 1.2.5.2数组的排序

1. 冒泡排序

冒泡排序是一种简单的交换排序算法，它重复地遍历要排序的列表，比较相邻元素，如果顺序错误就交换它们。

在排序过程中，较大的元素会像气泡一样逐渐"上浮"到数组的末尾（或较小元素"下沉"到开头）

核心操作就是**`比较arr[i]与arr[i+1]的相对大小，`**再交换位置

例.将数组升序排序

```C++
    int arr[5] = {22, 33, 55, 44, 11};
    int len = sizeof(arr)/sizeof(arr[0]);
    int i, x, m;
    
    for(x = 0; x < len - 1; x++) {      
        for(i = 0; i < len; i++) {
            if(arr[i] > arr[i + 1]) {
                m = arr[i + 1];         
                arr[i + 1] = arr[i];
                arr[i] = m;
                }
        }
    }
        
```

**内层循环的作用：** 每次执行内层循环，会将当前未排序部分中的最大值"冒泡"到该部分的末尾。 例如，在升序排序中，第一轮内层循环结束后，`arr[n-1]`（最后一个位置）存放的是整个数组的最大值，其余元素仍未排序。

**外层循环的作用：** 外层循环**控制排序的轮数**。每执行一轮，就确定一个当前未排序部分的最大值并放到正确位置。由于每轮确定一个数，因此对于长度为 `n` 的数组，最多需要 `n-1` 轮即可完成全部排序。

1. 选择排序

选择排序是一种简单直观的排序算法，其核心思想是：每次从未排序部分选择最小（或最大）元素，放到已排序部分的末尾。

例.将数组升序排序

```C++
    int arr[5] = {22, 33, 55, 44, 11};
    int len = sizeof(arr)/sizeof(arr[0]);
    int i, x, m;                        //循环控制变量和临时变量
    int min, min_index;                 //当前最小值及其索引位置
        
    //外层循环：控制排序轮数，每轮确定一个位置
    for(i = 0; i < len; i++) {          
        min = arr[i];
        min_index = i;
    //内层循环：在未排序部分[i, len-1]中查找最小值
        for(x = i; x < len; x++) {        
            if(min > arr[x]) {
                min = arr[x];           //记录新最小值
                min_index = x;          //记录新最小值的索引
            }
        }           
        arr[min_index] = a[i];
        a[i] = min;
    }    
```

简单来说，就是先找出最小值放在`arr[0]`,在剩下的元素中找出最小的放在`arr[1]`，多次执行以完成升序排序问题

第一轮：在全部元素中找最小值 → 放到 `arr[0]`

第二轮：在 `arr[1]` 到 `arr[n-1]` 中找最小值 → 放到 `arr[1]`

重   复：每次在剩余元素中找最小值，放到当前位置，完成升序排序任务

### 1.3二维数组

二维数组可以看作是“数组的数组”，**在内存中依然是连续存储的**。

#### 1.3.1二维维数组的声明

语法格式：

```C++
数据类型 数组名[行数][列数]; 
```

数据类型 ：数组中存储元素的类型（如  int 、 float ）。 行数 ：表格的行数，必须是编译期常量，可以省略。 列数 ：表格的列数，必须是编译期常量，且不可省略。

本质上该数组是一个包含 行数 个一维数组，每个一维数组有 列数 个元素。

#### 1.3.2二维数组的初始化

按行初始化（推荐） 用嵌套大括号按行分组，代码清晰直观。

```C++
int arr[3][4] = {
    {1, 2, 3, 4},   // 第1行
    {5, 6, 7, 8},   // 第2行
    {9, 10, 11, 12} // 第3行
};
```

省略行数初始化 编译器会根据初始化的行数自动推导行数，但列数永远不能省略。

```C++
int arr[][4] = {
    {1, 2, 3, 4},
    {5, 6, 7, 8}
};
```

简化初始化 按行顺序填充所有元素，适合元素较少的场景。

```C++
int arr[3][4] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12};
```

空初始化 所有元素自动初始化为0，适合后续动态赋值。

```C++
int arr[3][4] = {0};
```

#### 1.3.3二维数组的遍历

二维数组的遍历需要嵌套循环，外层循环遍历行，内层循环遍历列。 核心逻辑：通过arr[i][j]访问第 i 行第 j 列的元素。 循环条件：外层 i < 行数，内层 j < 列数。

- for循环下标法

```C++
#include <stdio.h>

int main() {
    int arr[3][4] = {
        {1, 2, 3, 4},
        {5, 6, 7, 8},
        {9, 10, 11, 12}
    };
    // 计算行数和列数
    int rows = sizeof(arr) / sizeof(arr[0]);
    int cols = sizeof(arr[0]) / sizeof(arr[0][0]);

    // 1. for循环嵌套遍历
    printf("for循环遍历结果：\\n");
    for (int i = 0; i < rows; i++) {       // 外层：遍历行
        for (int j = 0; j < cols; j++) {   // 内层：遍历列
            printf("%d\\t", arr[i][j]);
        }
        printf("\\n"); // 每行结束换行
    }

    return 0;
}
```

运行结果：

```C++
for循环遍历结果：
1       2       3       4
5       6       7       8
9       10      11      12
```

- while循环法

```C++
#include <stdio.h>

int main() {
    int arr[3][4] = {
        {1, 2, 3, 4},
        {5, 6, 7, 8},
        {9, 10, 11, 12}
    };
    int rows = sizeof(arr) / sizeof(arr[0]);
    int cols = sizeof(arr[0]) / sizeof(arr[0][0]);

    // 2. while循环嵌套遍历
    printf("\\nwhile循环遍历结果：\\n");
    int i = 0; // 行计数器初始化
    while (i < rows) {
        int j = 0; // 每行开始时，重置列计数器
        while (j < cols) {
            printf("%d\\t", arr[i][j]);
            j++; // 列计数器自增
        }
        printf("\\n");
        i++; // 行计数器自增
    }

    return 0;
}
```

运行结果：

```C++
while循环遍历结果：
1       2       3       4
5       6       7       8
9       10      11      12
```

#### 1.3.4二维数组与一维数组的联系

对于二维数组 int arr[M][N]： 整个数组可以看作是一个包含 M个元素的一维数组；这个一维数组里的每个元素本身，又是一个包含 N 个 int 元素的一维数组。  所以，arr[i] 就代表第 i+1 行这个一维数组的数组名，它指向该行的第一个元素。

```C++
#include <stdio.h>

int main() {
    int arr[3][4] = {
        {1, 2, 3, 4},
        {5, 6, 7, 8},
        {9, 10, 11, 12}
    };

    // 将二维数组的一行看作一维数组
    int* row1 = arr[0]; // arr[0] 是第1行的数组名，退化为指针
    printf("第1行的元素：");
    for (int j = 0; j < 4; j++) {
        printf("%d ", row1[j]); // 像访问一维数组一样访问
    }
    printf("\\n");

    // 直接用数组名访问
    printf("第2行第3列元素：%d\\n", arr[1][2]);
    // 等价于把arr[1]当作一维数组访问
    printf("等价写法：%d\\n", *(arr[1] + 2));

    return 0;
}
```

运行结果：

```C++
第1行的元素：1 2 3 4 
第2行第3列元素：7
等价写法：7
```

#### 1.3.5二维数组的运用

例：一个班级有 3 名学生，每个学生参加了4 门课程的考试。我们需要用一个二维数组来存储这些成绩，并计算出：

(1):每位学生的平均分。

(2):全班的最高分。

```C
#include <stdio.h>

int main() {
    // 定义一个 3行 4列的二维数组
    int grades[3][4] = {
        {85, 92, 78, 90}, // 学生0 的成绩
        {70, 88, 95, 82}, // 学生1 的成绩
        {92, 90, 89, 94}  // 学生2 的成绩
    };

    int maxGrade = grades[0][0];

    printf("--- 学生成绩分析 ---\n");

    // 遍历行（学生）
    for (int i = 0; i < 3; i++) {
        int sum = 0;
        
        // 遍历列（科目）
        for (int j = 0; j < 4; j++) {
            sum += grades[i][j]; // 累加该学生的所有科目成绩
            
            // 寻找全班最高分
            if (grades[i][j] > maxGrade) {
                maxGrade = grades[i][j];
            }
        }
        
        float average = sum / 4.0;
        printf("学生 %d 的平均分: %.2f\n", i, average);
    }

    printf("--------------------\n");
    printf("全班最高分为: %d\n", maxGrade);

    return 0;
}
```

![img](https://gcn59lcrd80x.feishu.cn/space/api/box/stream/download/asynccode/?code=YTNiYTU1NzNjNTAxMjIyNTcwODUyMjBkM2JkNDQ0MDBfUGNzeEMzQ3p6d29NRU9uNXl3SEpKUjZRV0V1d0R0cWdfVG9rZW46RlR0aGJYZmlXb29MSTB4dE5tdGNxdDJLbkp6XzE3NzEwNjEzMDA6MTc3MTA2NDkwMF9WNA)

## 2.结构体

在本章的开始，我们仅仅输入学生的成绩，如果还要存储一个学生的完整信息（学号int、姓名char、成绩int、性别char），这些内容的数据类型并不相同，我们不能只使用数组，需要在引入结构体的概念来帮助我们存储数据。

### 2.1结构体的定义和声明

```C++
struct 结构体名 { 
       数据类型 成员名1;
       数据类型 成员名2; 
       ... 
};   //末尾分号不可省略
```

结构体是把不同类型的变量整合为一个整体，描述学生、坐标、商品等复杂对象，实现数据聚合存储。

在给结构体命名时推荐首字母大写（如：Student、Point等），来区分普通变量。

结构体成员变量类型有基础内置类型：int、float、double、char；和数组类型：char[]、int[]、float[]。 在给成员命名时，可与外部变量重名，互不冲突；不同成员间名称不可重复。

例：定义Student类型，包含：姓名、学号、成绩。

```C
#include <stdio.h>
#include <string.h>

// 1. 定义结构体类型 Student
typedef struct {
    char name[20];   // 姓名
    int id;          // 学号
    float score;     // 成绩
} Student;

int main() {
    // 2. 声明并初始化一个结构体数组（存储 3 个学生）
    Student class_1[3] = {
        {"Alice", 101, 92.5},
        {"Bob", 102, 88.0},
        {"Charlie", 103, 95.0}
    };

    // 3. 动态修改数据示例
    // 假设我们要修改 Bob 的成绩
    class_1[1].score = 89.5;

    // 4. 打印表头
    printf("%-10s %-10s %-10s\n", "姓名", "学号", "成绩");
    printf("-------------------------------\n");

    // 5. 遍历数组并输出学生信息
    for (int i = 0; i < 3; i++) {
        printf("%-10s %-10d %-10.1f\n", 
                class_1[i].name, 
                class_1[i].id, 
                class_1[i].score);
    }

    // 6. 简单的逻辑：找出最高分
    int top_student_index = 0;
    for (int i = 1; i < 3; i++) {
        if (class_1[i].score > class_1[top_student_index].score) {
            top_student_index = i;
        }
    }

    printf("-------------------------------\n");
    printf("最高分获得者是: %s，分数为: %.1f\n", 
            class_1[top_student_index].name, 
            class_1[top_student_index].score);

    return 0;
}
```

![img](https://gcn59lcrd80x.feishu.cn/space/api/box/stream/download/asynccode/?code=MDU5OWNlYzQ1M2VmY2ZjNTA0MTg2ODljODk4ZDlkMmFfY0pzMk8yV0hReUpKcjg3OTVsOVZweWlqaUpGa1ZOcWhfVG9rZW46WFRGNmI5dnBZb1RveG94RjFmZWM5eGEzbmpkXzE3NzEwNjEzMDA6MTc3MTA2NDkwMF9WNA)

例：定义Goods类型，包含：名称、价格、库存。

```C
#include <stdio.h>

// 1. 定义 Goods 结构体
typedef struct {
    char name[30];    // 商品名称
    double price;     // 价格（使用 double 精度更高）
    int stock;        // 库存数量
} Goods;

int main() {
    // 2. 声明一个结构体数组，模拟小仓库
    int n = 3;
    Goods inventory[3];
    double total_value = 0;

    printf("--- 简易库存录入系统 ---\n");

    // 3. 循环录入商品信息
    for (int i = 0; i < n; i++) {
        printf("\n请输入第 %d 个商品的信息：\n", i + 1);
        
        printf("名称: ");
        scanf("%s", inventory[i].name);
        
        printf("价格: ");
        scanf("%lf", &inventory[i].price);
        
        printf("库存: ");
        scanf("%d", &inventory[i].stock);
        
        // 计算该商品的总价值并累加
        total_value += inventory[i].price * inventory[i].stock;
    }

    // 4. 格式化输出库存清单
    printf("\n%-15s %-10s %-10s %-10s\n", "商品名称", "单价", "库存", "总价值");
    printf("--------------------------------------------------\n");
    
    for (int i = 0; i < n; i++) {
        printf("%-15s %-10.2f %-10d %-10.2f\n", 
                inventory[i].name, 
                inventory[i].price, 
                inventory[i].stock,
                inventory[i].price * inventory[i].stock);
    }

    printf("--------------------------------------------------\n");
    printf("仓库总评估价值: %.2f 元\n", total_value);

    return 0;
}
```

![img](https://gcn59lcrd80x.feishu.cn/space/api/box/stream/download/asynccode/?code=MmEzNTRmMjhkNjQ0ZGRiMzdlMWE3ZTNjYzdlMGFiNTNfNVlJQm9PUmh1T3pLaDI1UDhaS1dDb2Nja05EZWpsUWtfVG9rZW46Szc5VWIySFJrb3FRQTJ4Mll3ZmM2dFRPblVhXzE3NzEwNjEzMDA6MTc3MTA2NDkwMF9WNA)

声明的作用域分为全局声名和局部声明，声明的位置决定了结构体的可用范围：

- 全局声明：将结构体声明写在所有函数之外（如 main 函数前）；整个程序的所有函数中，都可使用该结构体定义变量，无范围限制。

```C++
// 全局声明：所有函数均可使用Student类型
struct Student {
    char name[20];
    int id;
    float score;
};

int main() {
    // 可直接定义变量
    struct Student stu;
    return 0;
}
```

- 局部声明：将结构体声明写在某个函数内部（如 main 函数中）；仅在声明所在的函数内可使用，外部函数无法识别该类型。

```C++
int main() {
    // 局部声明：仅main函数内可用
    struct Point {
        int x;
        int y;
    };
    struct Point p; // 合法
    return 0;
}
// 外部函数无法使用Point类型，编译报错
```

注意：不能在结构体内部直接声明自身类型的成员变量，会造成无限嵌套，编译器直接报错，可声明其他已完成声明的结构体作为成员（嵌套声明），需遵循先声明子结构体，再声明父结构体的顺序。

```C++
// 错误写法：自嵌套，编译报错
struct A {
    int a;
    struct A b; // 试图在A内部定义A类型变量，无限嵌套
};
```

### 2.2结构体的初始化

 结构体变量在定义时一定要初始化，可以一次性为所有成员赋值，未显式赋值的成员会被自动初始化为默认值（数值型为0，字符数组为空）。

初始化有以下三种形式：

- 按成员顺序初始化

```C++
// 假设已定义Student结构体
struct Student stu = {"张三", 1001, 95.5};
// 赋值顺序必须和结构体声明时的成员顺序完全一致：name → id → score
```

- 指定成员初始化

```C++
struct Student stu = {
    .id = 1002,
    .name = "李四",
    .score = 88.0
};
// 赋值顺序可以任意，未指定的成员自动置0，可读性更高，避免顺序错误
```

- 嵌套结构体初始化（成员为其他结构体时）

```C++
// 先定义子结构体Date
struct Date { int year; int month; int day; };
// 父结构体Employee包含Date成员
struct Employee { char name[20]; int age; Date hire_date; };

// 嵌套初始化
struct Employee emp = {"王五", 25, {2024, 9, 1}};
// 或指定成员初始化
struct Employee emp = {
    .name = "赵六",
    .age = 30,
    .hire_date = {.year=2023, .month=6, .day=15}
};
```

### 2.3结构体成员的访问

语法格式： 

```C++
结构体变量名.成员名
```

结构体变量名：已经定义并初始化的结构体实例。 .：点运算符，是普通结构体变量访问成员的专属操作符。 成员名：结构体声明时定义的成员变量名称。

```C++
#include <stdio.h>
#include <string.h>

// 1. 先定义子结构体：日期
struct Date {
    int year;
    int month;
    int day;
};

// 2. 再定义父结构体：员工
struct Employee {
    char name[20];
    int age;
    struct Date hire_date; // 嵌套子结构体
};

int main() {
    // 3. 定义并初始化一个员工变量
    struct Employee emp;
    strcpy(emp.name, "赵六"); // 字符数组用strcpy赋值
    emp.age = 30;
    // 初始化嵌套的日期成员
    emp.hire_date.year = 2023;
    emp.hire_date.month = 6;
    emp.hire_date.day = 15;

    // 4. 访问并输出结构体成员
    printf("员工姓名：%s\n", emp.name);
    printf("员工年龄：%d\n", emp.age);
    printf("入职日期：%d年%d月%d日\n", 
           emp.hire_date.year, 
           emp.hire_date.month, 
           emp.hire_date.day);

    // 5. 修改结构体成员
    emp.age = 31; // 修改年龄
    emp.hire_date.day = 20; // 修改入职日
    printf("\n修改后：\n");
    printf("员工年龄：%d\n", emp.age);
    printf("入职日期：%d年%d月%d日\n", 
           emp.hire_date.year, 
           emp.hire_date.month, 
           emp.hire_date.day);

    return 0;
}
```

运行结果：

```C++
员工姓名：赵六
员工年龄：30
入职日期：2023年6月15日

修改后：
员工年龄：31
入职日期：2023年6月20日
```

emp.name获取员工姓名。 emp.age = 31修改员工年龄。 对于嵌套的结构体，需要逐层使用.运算符，比如 emp.hire_date.year。 这表示先访问 emp的hire_date成员，再访问该成员的year 属性。

```C++
 // 错误写法：跳过了hire_date成员
emp.year = 2023;
// 正确写法
emp.hire_date.year = 2023;
```

结构体中的字符数组成员（如 name[20]）不能直接用 =赋值，必须使用 strcpy 函数。

```C++
// 错误写法
emp.name = "赵六";
// 正确写法
strcpy(emp.name, "赵六");
```

### 2.4结构体数组

语法结构：

```C++
struct 结构体名 数组名[长度];
```

数组的每个元素都是一个完整的结构体变量。

```C++
#include <stdio.h>
#include <string.h>

// 定义学生结构体
struct Student {
    char name[20];
    int id;
    float score;
};

int main() {
    // 1. 初始化结构体数组
    struct Student stu_arr[] = {
        {"张三", 1001, 95.5},
        {"李四", 1002, 88.0},
        {"王五", 1003, 92.5}
    };
    // 计算数组长度
    int len = sizeof(stu_arr) / sizeof(stu_arr[0]);

    // 2. 遍历输出所有学生信息
    printf("所有学生信息：\\n");
    for (int i = 0; i < len; i++) {
        printf("第%d个学生：\\n", i+1);
        printf("姓名：%s\\n", stu_arr[i].name);
        printf("学号：%d\\n", stu_arr[i].id);
        printf("成绩：%.1f\\n\\n", stu_arr[i].score);
    }

    // 3. 修改结构体数组元素
    // 将李四的成绩修改为90.0
    strcpy(stu_arr[1].name, "李四同学");
    stu_arr[1].score = 90.0;

    // 4. 查找成绩最高的学生
    int max_index = 0;
    for (int i = 1; i < len; i++) {
        if (stu_arr[i].score > stu_arr[max_index].score) {
            max_index = i;
        }
    }
    printf("成绩最高的学生是：%s，成绩：%.1f\\n", 
           stu_arr[max_index].name, 
           stu_arr[max_index].score);

    return 0;
}
```

运行结果：

```C++
所有学生信息：
第1个学生：
姓名：张三
学号：1001
成绩：95.5

第2个学生：
姓名：李四
学号：1002
成绩：88.0

第3个学生：
姓名：王五
学号：1003
成绩：92.5

成绩最高的学生是：张三，成绩：95.5
```

## 3.综合运用

### 1.编写一个程序，定义两个 3 X 3 的整型二维数组，由用户输入数据，计算这两个矩阵的和，并将结果存储在第三个二维数组中输出。

解析：

```C++
#include <stdio.h>

int main() {
    // 1.3.1 二维数组的声明
    int matrixA[3][3], matrixB[3][3], sumMatrix[3][3];

    // 输入第一个矩阵 A
    printf("请输入矩阵 A 的数据 (3x3):\n");
    for (int i = 0; i < 3; i++) { // 外层循环遍历行
        for (int j = 0; j < 3; j++) { // 内层循环遍历列
            scanf("%d", &matrixA[i][j]);
        }
    }

    // 输入第二个矩阵 B
    printf("请输入矩阵 B 的数据 (3x3):\n");
    for (int i = 0; i < 3; i++) {
        for (int j = 0; j < 3; j++) {
            scanf("%d", &matrixB[i][j]);
        }
    }

    // 1.3.5 二维数组的运用：矩阵相加
    // 逻辑：对应位置的元素相加，即 sum[i][j] = A[i][j] + B[i][j]
    for (int i = 0; i < 3; i++) {
        for (int j = 0; j < 3; j++) {
            sumMatrix[i][j] = matrixA[i][j] + matrixB[i][j];
        }
    }

    // 1.3.3 二维数组的遍历：输出结果
    printf("\n矩阵 A + B 的结果为:\n");
    for (int i = 0; i < 3; i++) {
        for (int j = 0; j < 3; j++) {
            printf("%d\t", sumMatrix[i][j]);
        }
        printf("\n"); // 每打印完一行换行
    }

    return 0;
}
```

![img](https://gcn59lcrd80x.feishu.cn/space/api/box/stream/download/asynccode/?code=YjUzYzY3ODJiOTE2NmJlMGM5YTM3MGM5NTY3NjIyOTlfMjRpM0pRRWhBbDhxYTc2NUd6clo5S2ZZSUJGZFI2cFpfVG9rZW46STVVV2JYQ2xIb1FJYWN4YTdGYWM4Vm80blFDXzE3NzEwNjEzMDA6MTc3MTA2NDkwMF9WNA)

在输出结果时，使用 `\t`（制表符）可以让矩阵的列对齐，使用 `printf("\n")` 确保每行打印完后换到下一行，从而呈现出矩阵的形状。

二维数组的操作离不开双重循环。外层循环控制“行”，内层循环控制“列”。

虽然我们在代码中使用 `matrix[i][j]` 这种直观的下标，但在内存中，这些数据是按行连续存储的。例如 `matrix[1][0]` 实际上是数组中的第 4 个元素。

### 2.定义一个 n X n的二维数组，编写代码计算该矩阵“外圈”所有元素的总和（即第一行、最后一行、第一列、最后一列的交集）。

解析：

```C
#include <stdio.h>

#define N 4  // 定义矩阵维数为 4x4

int main() {
    int matrix[N][N];
    int sum = 0;

    // 1. 输入矩阵数据
    printf("请输入 %d x %d 矩阵的元素：\n", N, N);
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < N; j++) {
            scanf("%d", &matrix[i][j]);
        }
    }

    // 2. 计算外圈总和 (算法优化版)
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < N; j++) {
            // 判断是否处于边界：第一行、最后一行、第一列、最后一列
            if (i == 0 || i == N - 1 || j == 0 || j == N - 1) {
                sum += matrix[i][j];
            }
        }
    }

    // 3. 输出矩阵（可选，用于直观查看）
    printf("\n当前矩阵为：\n");
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < N; j++) {
            printf("%d\t", matrix[i][j]);
        }
        printf("\n");
    }

    printf("\n该矩阵“外圈”元素的总和为：%d\n", sum);

    return 0;
}
```

![img](https://gcn59lcrd80x.feishu.cn/space/api/box/stream/download/asynccode/?code=Y2RjN2M4Yjk4ZTQxM2Q0MzBhMzdiZTlkMmU0NWFhMGFfNHVvTjh4c3FpTXRFV3lPTkpYYmNPcVJnNXZyVnFnM1NfVG9rZW46SUQ5NGJSUXNGb3VSZXV4ckpzcmNIam4xbkdlXzE3NzEwNjEzMDA6MTc3MTA2NDkwMF9WNA)

外圈元素的特征非常明显，可以用坐标 $$(i, j$$ 的极端值来表示：

**上边界**：行索引 i = 0

**下边界**：行索引 i = n-1

**左边界**：列索引 j = 0

**右边界**：列索引 j = n-1

只要满足以上**任意一个**条件（逻辑“或” `||`），该元素就属于外圈。

### 3.定义一个 `float score[5][3]`的数组，存储 5 个学生 3 门课的成绩。计算：

### (1)每名学生的平均分。

### (2)每门课程的全班平均分。

```C
#include <stdio.h>

int main() {
    // 1.3.1 二维数组的声明：5名学生，3门课程
    float score[5][3];
    float student_avg[5] = {0}; // 存储每名学生的平均分
    float course_avg[3] = {0};  // 存储每门课程的平均分

    // 1. 输入成绩
    printf("请输入 5 名学生各 3 门课的成绩：\n");
    for (int i = 0; i < 5; i++) {
        printf("请输入学生 %d 的 3 门课成绩: ", i + 1);
        for (int j = 0; j < 3; j++) {
            scanf("%f", &score[i][j]);
        }
    }

    // 2. 计算每名学生的平均分 (横向求和)
    for (int i = 0; i < 5; i++) {
        float sum = 0;
        for (int j = 0; j < 3; j++) {
            sum += score[i][j];
        }
        student_avg[i] = sum / 3.0;
    }

    // 3. 计算每门课程的平均分 (纵向求和)
    for (int j = 0; j < 3; j++) {
        float sum = 0;
        for (int i = 0; i < 5; i++) {
            sum += score[i][j];
        }
        course_avg[j] = sum / 5.0;
    }

    // 4. 输出结果
    printf("\n--- 统计结果 ---\n");
    for (int i = 0; i < 5; i++) {
        printf("学生 %d 的平均分: %.2f\n", i + 1, student_avg[i]);
    }
    printf("----------------\n");
    for (int j = 0; j < 3; j++) {
        printf("课程 %d 的全班平均分: %.2f\n", j + 1, course_avg[j]);
    }

    return 0;
}
```

![img](https://gcn59lcrd80x.feishu.cn/space/api/box/stream/download/asynccode/?code=ZTZmNjFkYTU2NDI4M2JjMWZmNTM2YTFhZThhZjFlNDNfWVFLWGVEM21IcWNXQUc3SFpFYTl6WjMyZmhEQ2ppbTJfVG9rZW46TlB3Z2JIbmdNb0NDeXR4czJYNWNDMUk3bndjXzE3NzEwNjEzMDA6MTc3MTA2NDkwMF9WNA)

**计算学生平均分**：属于“按行统计”。我们固定行索引 `i`，让列索引 `j` 跑完 [0, 2]。这符合 C 语言内存中按行排列的自然顺序

**计算课程平均分**：属于“按列统计”。我们需要固定列索引 `j`，让行索引 `i` 跑完 [0, 4]。在嵌套循环中，要把 `j` 放在外层，`i` 放在内层。

### 4.定义 `Goods` 类型（名称、单价、库存量）。编写程序遍历一个拥有 10 件商品的数组，输出所有“库存量小于 5”的商品名称及联系补货信息。

解析：

```C
#include <stdio.h>

// 2.1 结构体的定义
typedef struct {
    char name[30];    // 商品名称
    float price;      // 单价
    int stock;        // 库存量
} Goods;

int main() {
    // 2.4 结构体数组的初始化（此处预设 10 件商品数据）
    // 在实际教材中，这部分也可以通过 scanf 录入
    Goods inventory[10] = {
        {"键盘", 129.0, 10},
        {"鼠标", 59.0, 3},   // 触发预警
        {"显示器", 899.0, 2}, // 触发预警
        {"耳机", 199.0, 15},
        {"数据线", 15.0, 4},  // 触发预警
        {"充电头", 45.0, 8},
        {"U盘", 65.0, 1},     // 触发预警
        {"散热支架", 35.0, 12},
        {"网线", 12.0, 20},
        {"鼠标垫", 9.9, 4}    // 触发预警
    };

    printf("========= 库存预警清单 =========\n");
    printf("%-15s %-10s %-10s\n", "待补货商品", "当前库存", "处理建议");
    printf("--------------------------------\n");

    int warning_count = 0;

    // 2.3 结构体成员的访问与遍历
    for (int i = 0; i < 10; i++) {
        // 核心逻辑：判断库存量是否小于 5
        if (inventory[i].stock < 5) {
            printf("%-15s %-10d %-10s\n", 
                   inventory[i].name, 
                   inventory[i].stock, 
                   "立即联系供应商");
            warning_count++;
        }
    }

    if (warning_count == 0) {
        printf("所有商品库存充足。\n");
    } else {
        printf("--------------------------------\n");
        printf("统计：共有 %d 项商品需要补货。\n", warning_count);
    }

    return 0;
}
```

![img](https://gcn59lcrd80x.feishu.cn/space/api/box/stream/download/asynccode/?code=MDMyYjA5YWE4Yzk3NTVlZTMwNzU4MGY0MjhlNDliZWVfR0Zoa2JSQ2tJYUtZQ1VMVmVrTlRhRGhuZWhucEUxZzRfVG9rZW46S1RndGJxZUZRb0hic094RDNzS2M5YzN6bk1jXzE3NzEwNjEzMDA6MTc3MTA2NDkwMF9WNA)

使用 `typedef` 可以简化类型名，方便声明数组。

在输出姓名时使用 `%-15s`（左对齐，占 15 位），是为了确保即使商品名称长度不同，后面的“库存”和“处理建议”列也能对齐

### 5.定义结构体 `Contact`（姓名、电话、地址）。编写程序实现：录入 3 个联系人。

### 提供一个“搜索”功能：用户输入姓名，程序输出对应的电话和地址。

```C
#include <stdio.h>
#include <string.h>

// 2.1 定义联系人结构体
typedef struct {
    char name[30];    // 姓名
    char phone[20];   // 电话
    char address[50]; // 地址
} Contact;

int main() {
    // 2.4 声明结构体数组，存储 3 个联系人
    Contact list[3];
    char searchName[30];
    int found = 0;

    // 1. 录入信息
    printf("--- 录入联系人信息 (共3人) ---\n");
    for (int i = 0; i < 3; i++) {
        printf("请输入第 %d 个人的信息：\n", i + 1);
        printf("姓名: ");
        scanf("%s", list[i].name);
        printf("电话: ");
        scanf("%s", list[i].phone);
        printf("地址: ");
        scanf("%s", list[i].address);
    }

    // 2. 搜索功能
    printf("\n--- 联系人搜索 ---\n");
    printf("请输入要查找的姓名: ");
    scanf("%s", searchName);

    // 3. 遍历数组进行匹配
    for (int i = 0; i < 3; i++) {
        // 使用 strcmp 函数比较字符串是否相等
        // 如果返回 0，表示字符串完全匹配
        if (strcmp(list[i].name, searchName) == 0) {
            printf("\n查找成功！信息如下：\n");
            printf("姓名: %s\n", list[i].name);
            printf("电话: %s\n", list[i].phone);
            printf("地址: %s\n", list[i].address);
            found = 1;
            break; // 找到后跳出循环
        }
    }

    if (!found) {
        printf("\n抱歉，未找到名为 '%s' 的联系人。\n", searchName);
    }

    return 0;
}
```

![img](https://gcn59lcrd80x.feishu.cn/space/api/box/stream/download/asynccode/?code=Zjg0MzQwZDAzZTQxODJjNmI2ZDEwMDRkNmIyYjQ5NTNfTVFtdUNpMXg3RlZUQjRxTW02djFHeE5QYzR3UjgwWjNfVG9rZW46U0dLMWJrSEhhb0JteTB4VnBsaGM5MEprbmtkXzE3NzEwNjEzMDA6MTc3MTA2NDkwMF9WNA)

**不能**直接使用 `if (list[i].name == searchName)`。因为数组名代表地址，这样比较的是两个字符串的存储地址而不是内容。

**必须**使用标准库 `<string.h>` 中的 `strcmp` 函数。`strcmp(s1, s2) == 0` 表示两个字符串内容完全相同。

输入地址时不要带空格（因为 `%s` 遇到空格会停止）。如果需要支持空格，建议引导学生学习 `fgets()` 函数。

### 6.定义一个包含10个整数的数组，通过循环依次赋值为1~10，然后逆序输出所有元素。

解析：

```C++
#include <stdio.h>
int main()
{
    int arr[10] = {};                
    // 声明并初始化一个包含10个整数的数组，所有元素自动设为0
    int i;
    // 第一个for循环：为数组元素赋值
    for(i = 0; i < 10; i++) {
        arr[i] = i + 1;
    }
    // 第二个for循环：顺序输出数组所有元素
    for(i = 0;i < 10; i++) {
        printf("arr[%d]=%d\n", i, arr[i]);
    }
    
    return 0;
}  
```

运行结果:

```C++
arr[0]=1
arr[1]=2
arr[2]=3
arr[3]=4
arr[4]=5
arr[5]=6
arr[6]=7
arr[7]=8
arr[8]=9
arr[9]=10
```

### 7.输入一个长度不超过100的字符串（不含空格），统计其中大写字母、小写字母和数字字符的数量，并分别输出。

解析：

```C++
#include <stdio.h>
int main()
{
    char str[100] = {};                        // 定义字符数组，存储输入的字符串
    int dig = 0;                               // 数字字符计数器
    int En = 0;                                // 大写字母计数器
    int en = 0;                                // 小写字母计数器
    int i = 0;                                 // 数组下标/循环控制变量
    
    printf("请输入一个字符串（不含空格）: ");
    scanf("%s", str);                          // 读取字符串（遇到空格停止）
    
    // 遍历字符串直到遇到结束符'\0'
    while(str[i] != '\0') {
        // 判断字符类型
        if(str[i] >= 'A' && str[i] <= 'Z') {
            En++;                              // 大写字母计数
        }
        else if(str[i] >= 'a' && str[i] <= 'z') {
            en++;                              // 小写字母计数
        }
        else if(str[i] >= '0' && str[i] <= '9') {
            dig++;                             // 数字字符计数
        }
        // 其他字符（符号等）不统计
        i++;                                   // 处理下一个字符
    }                     
    
    // 输出统计结果
    printf("大写字母的数量为%d\n", En);
    printf("小写字母的数量为%d\n", en);
    printf("数字字符的数量为%d\n", dig);
    
    return 0;
}
```

逻辑流程：

- 大写字母 → 计数 → 跳过后续判断
- 否则如果是小写字母 → 计数 → 跳过后续判断
- 否则如果是数字 → 计数 → 跳过后续判断
- 否则（其他字符）→ 直接跳过

![img](https://gcn59lcrd80x.feishu.cn/space/api/box/stream/download/asynccode/?code=YzYyYTY4NmFkYjAxM2JhMzRhZjFkYTNiM2E3ZGZkMzVfMTFUbHdiYU5UOHI3QUdqOHFOV3BaQWF3bEdtaGRiV3VfVG9rZW46TTh2MGJaekt3b0VwNWN4Q2duZGNPeGNabmZlXzE3NzEwNjEzMDA6MTc3MTA2NDkwMF9WNA)

### 8.输入10个学生成绩（0-100），存储到数组中，找出最高分和最低分对应的学号，计算平均分（保留1位小数），并统计高于平均分的人数。

解析：

```C++
#include <stdio.h>
int main()
{
    // 定义并初始化学生成绩数组
    // 初始化变量
    int arr[10] = {67, 88, 42, 75, 92, 63, 81, 55, 96, 71};
    int max = arr[0];
    int min = arr[0];
    int sum = 0, num = 0;
    int i;
    
    // 第一个for循环：完成三项任务    
    for(i = 0; i < 10; i++) {
        sum += arr[i];                // 任务1：累加计算总分
        
        if(max < arr[i]) {            // 任务2：找出最高分
            max = arr[i];             // 更新最高分
        }
        
        if(min > arr[i]) {            // 任务3：找出最低分
            min = arr[i];             // 更新最低分
        }
    }
    
    // 计算平均分（使用10.0确保浮点数除法）
    float x = sum / 10.0;
    
    for(i = 0; i < 10; i++) {          // 判断成绩是否高于平均分
        if(arr[i] > x) {
            num++;
        }
    }
    
    // 输出统计结果
    printf("最高分为%d\n最低分为%d\n平均分为%.1f\n高于平均分的人数为%d", max, min, x, num);
    
    return 0;
}   
```

![img](https://gcn59lcrd80x.feishu.cn/space/api/box/stream/download/asynccode/?code=ODVkYjJkNTkyM2ZmNDBjZTA5M2IwM2RjNzU4MDFjODNfaU0zY0VsYWJ4a3hGTGo3ZTRTeFJxU05Vb3pjbVJwcVlfVG9rZW46WEJ2NWJzY3Rpb2F0MUR4YzdCWmNJeFo3blNmXzE3NzEwNjEzMDA6MTc3MTA2NDkwMF9WNA)

### 9.输入两个长度相同的整数数组A和B（长度≤50），生成新数组C，其中C[i] =

- 0（当A[i] = B[i]）
- 1（当A[i] > B[i]）
- -1（当A[i] < B[i]）

最后输出数组C的所有元素。

解析：

```C++
#include <stdio.h>
int main()
{
    int a[5] = {2, 3, 6, 8, 0};
    int b[5] = {4, 5, 6, 7, 8};
    int i;
    int c[5];
    
    // for循环：遍历数组的每个元素
    for(i = 0; i < 5; i++) {
        // 比较a[i]和b[i]的大小关系
        if(a[i] > b[i]) {                    // 情况1：a[i]大于b[i]
            c[i] = 1;                        // 对应规则：c[i] = 1                  
        }
        else if(a[i] == b[i]) {              // 情况2：a[i]等于b[i]           
            c[i] = 0;                        // 对应规则：c[i] = 0              
        }
        else {                               // 情况3：a[i]小于b[i]                     
            c[i] = -1;                       // 对应规则：c[i] = -1
        }
    }
    
    // 输出循环：显示结果数组c的所有元素
    for(i = 0; i < 5; i++) {
        printf("c[%d]=%d\n", i, c[i]);
    }
    
    return 0;
}
```

![img](https://gcn59lcrd80x.feishu.cn/space/api/box/stream/download/asynccode/?code=ZmYxZTk5ZWQ1NzhlMDc0ZDlkZGZmYzdkMWNmMDFiMWJfNnRkTDc1Z3BkOTdaMGJxbjdkOVlyMTJxajkwZFp0QVlfVG9rZW46UkFOMmI4YVpYb2pudDh4Z0VKTmNGSTIxbnpZXzE3NzEwNjEzMDA6MTc3MTA2NDkwMF9WNA)

### 10.定义`Goods`结构体（名称，价格，序列号），将商品按价格低到高排序输出，同时输出名称和序列号

解析：

```C++
#include <stdio.h>
    // 定义商品结构体类型

typedef struct {
        char name[20];                    // 商品名称，最多19个字符+1个结束符
        float price;                      // 商品价格，浮点型
        int Id;                           // 商品序列号，整型
    } Goods;

int main()
{
    // 声明并初始化商品数组，包含5种饮料
    Goods Block_drink[5] = {
        {"农夫山泉矿泉水", 2.00, 1123665},
        {"百岁山矿泉水", 3.50, 1124966},
        {"冰红茶饮料", 3.90, 1125977},
        {"可口可乐饮料", 3.70, 1125967},
        {"百事可乐饮料", 3.81, 1125897}
    };
    // 临时变量，用于交换两个商品位置
    Goods Exchange;
    int i, x, min_index;
    float min;
    
    // 选择排序：按价格从低到高排序// 外层循环：确定第i个位置应该放哪个商品
    for(i = 0; i < 5; i++) {
        min_index = i;                    // 假设当前i位置是最小值索引        
        min = Block_drink[i].price;       // 记录当前i位置的价格作为初始最小值
        
        // 内层循环：在未排序部分[i,4]中寻找真正的最小价格
        for(x = i; x < 5; x++) {
            
            if(min > Block_drink[x].price) {
                // 更新最小价格与索引
                min = Block_drink[x].price;
                min_index = x;
            }
        }
        // 交换：将找到的最小价格商品放到i位置
        Exchange = Block_drink[min_index];
        // 保存最小值商品
        Block_drink[min_index] = Block_drink[i];
        // 将i位置的商品移到最小值位置
        Block_drink[i] = Exchange;
        // 将最小值商品放到i位置
    }
    
    // 输出排序后的商品列表
    printf("本店开业大吉，有以下商品售卖:\n");
    printf("==============================\n");
    
    // 遍历并输出每个商品的信息
    for(i = 0; i < 5; i++) {
        printf("商品名称: %s\n", Block_drink[i].name);            // 输出商品名
        printf("商品价格: %.2f\n", Block_drink[i].price);         // 输出价格，保留2位小数   
        printf("商品序列号: %d\n", Block_drink[i].Id);            // 输出序列号
    printf("==============================\n");
    }
    
    return 0;
}
```

![img](https://gcn59lcrd80x.feishu.cn/space/api/box/stream/download/asynccode/?code=NTRjZjZiYTI1NDA5ZDUwNTQ3ZDdhOTgyMmQzM2Q3NDRfYlFJRkw1eDR3QUF6TndpZ3VmMk1vdGNIYnNuWnhrbnZfVG9rZW46VnlUQWJhcDJIb0RtelZ4STN0OWNtbTJXbjJnXzE3NzEwNjEzMDA6MTc3MTA2NDkwMF9WNA)

交换结构体时，中间变量`Exchange`必须是相同的结构体类型

在使用选择排序时，最小值的索引`min_index`尤为重要